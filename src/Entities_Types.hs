{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.3)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Entities_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import qualified Structure_Types
import qualified Metadata_Types
import qualified Uuid_Types
import qualified Linking_Types


data Entity = Entity  { entity_uuid :: Uuid_Types.UUID
  , entity_mentionIdList :: (Vector.Vector Uuid_Types.UUID)
  , entity_type :: P.Maybe LT.Text
  , entity_confidence :: P.Maybe P.Double
  , entity_canonicalName :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Entity where
  hashWithSalt salt record = salt   `H.hashWithSalt` entity_uuid record   `H.hashWithSalt` entity_mentionIdList record   `H.hashWithSalt` entity_type record   `H.hashWithSalt` entity_confidence record   `H.hashWithSalt` entity_canonicalName record  
instance QC.Arbitrary Entity where 
  arbitrary = M.liftM Entity (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Entity = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Entity{entity_uuid = entity_uuid obj} then P.Nothing else P.Just $ default_Entity{entity_uuid = entity_uuid obj}
    , if obj == default_Entity{entity_mentionIdList = entity_mentionIdList obj} then P.Nothing else P.Just $ default_Entity{entity_mentionIdList = entity_mentionIdList obj}
    , if obj == default_Entity{entity_type = entity_type obj} then P.Nothing else P.Just $ default_Entity{entity_type = entity_type obj}
    , if obj == default_Entity{entity_confidence = entity_confidence obj} then P.Nothing else P.Just $ default_Entity{entity_confidence = entity_confidence obj}
    , if obj == default_Entity{entity_canonicalName = entity_canonicalName obj} then P.Nothing else P.Just $ default_Entity{entity_canonicalName = entity_canonicalName obj}
    ]
from_Entity :: Entity -> T.ThriftVal
from_Entity record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v2))) $ entity_uuid record
  , (\_v2 -> P.Just (2, ("mentionIdList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v4 -> Uuid_Types.from_UUID _v4) $ Vector.toList _v2))) $ entity_mentionIdList record
  , (\_v2 -> (3, ("type",T.TString $ E.encodeUtf8 _v2))) <$> entity_type record
  , (\_v2 -> (4, ("confidence",T.TDouble _v2))) <$> entity_confidence record
  , (\_v2 -> (5, ("canonicalName",T.TString $ E.encodeUtf8 _v2))) <$> entity_canonicalName record
  ]
write_Entity :: (T.Protocol p, T.Transport t) => p t -> Entity -> P.IO ()
write_Entity oprot record = T.writeVal oprot $ from_Entity record
encode_Entity :: (T.Protocol p, T.Transport t) => p t -> Entity -> LBS.ByteString
encode_Entity oprot record = T.serializeVal oprot $ from_Entity record
to_Entity :: T.ThriftVal -> Entity
to_Entity (T.TStruct fields) = Entity{
  entity_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val6) -> (case _val6 of {T.TStruct _val7 -> (Uuid_Types.to_UUID (T.TStruct _val7)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  entity_mentionIdList = P.maybe (P.error "Missing required field: mentionIdList") (\(_,_val6) -> (case _val6 of {T.TList _ _val8 -> (Vector.fromList $ P.map (\_v9 -> (case _v9 of {T.TStruct _val10 -> (Uuid_Types.to_UUID (T.TStruct _val10)); _ -> P.error "wrong type"})) _val8); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  entity_type = P.maybe (P.Nothing) (\(_,_val6) -> P.Just (case _val6 of {T.TString _val11 -> E.decodeUtf8 _val11; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  entity_confidence = P.maybe (P.Nothing) (\(_,_val6) -> P.Just (case _val6 of {T.TDouble _val12 -> _val12; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  entity_canonicalName = P.maybe (P.Nothing) (\(_,_val6) -> P.Just (case _val6 of {T.TString _val13 -> E.decodeUtf8 _val13; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Entity _ = P.error "not a struct"
read_Entity :: (T.Transport t, T.Protocol p) => p t -> P.IO Entity
read_Entity iprot = to_Entity <$> T.readVal iprot (T.T_STRUCT typemap_Entity)
decode_Entity :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Entity
decode_Entity iprot bs = to_Entity $ T.deserializeVal iprot (T.T_STRUCT typemap_Entity) bs
typemap_Entity :: T.TypeMap
typemap_Entity = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("mentionIdList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID)))),(3,("type",T.T_STRING)),(4,("confidence",T.T_DOUBLE)),(5,("canonicalName",T.T_STRING))]
default_Entity :: Entity
default_Entity = Entity{
  entity_uuid = Uuid_Types.default_UUID,
  entity_mentionIdList = Vector.empty,
  entity_type = P.Nothing,
  entity_confidence = P.Nothing,
  entity_canonicalName = P.Nothing}
data EntitySet = EntitySet  { entitySet_uuid :: Uuid_Types.UUID
  , entitySet_metadata :: Metadata_Types.AnnotationMetadata
  , entitySet_entityList :: (Vector.Vector Entity)
  , entitySet_linkingList :: P.Maybe (Vector.Vector Linking_Types.Linking)
  , entitySet_mentionSetId :: P.Maybe Uuid_Types.UUID
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EntitySet where
  hashWithSalt salt record = salt   `H.hashWithSalt` entitySet_uuid record   `H.hashWithSalt` entitySet_metadata record   `H.hashWithSalt` entitySet_entityList record   `H.hashWithSalt` entitySet_linkingList record   `H.hashWithSalt` entitySet_mentionSetId record  
instance QC.Arbitrary EntitySet where 
  arbitrary = M.liftM EntitySet (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_EntitySet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EntitySet{entitySet_uuid = entitySet_uuid obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_uuid = entitySet_uuid obj}
    , if obj == default_EntitySet{entitySet_metadata = entitySet_metadata obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_metadata = entitySet_metadata obj}
    , if obj == default_EntitySet{entitySet_entityList = entitySet_entityList obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_entityList = entitySet_entityList obj}
    , if obj == default_EntitySet{entitySet_linkingList = entitySet_linkingList obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_linkingList = entitySet_linkingList obj}
    , if obj == default_EntitySet{entitySet_mentionSetId = entitySet_mentionSetId obj} then P.Nothing else P.Just $ default_EntitySet{entitySet_mentionSetId = entitySet_mentionSetId obj}
    ]
from_EntitySet :: EntitySet -> T.ThriftVal
from_EntitySet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v16 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v16))) $ entitySet_uuid record
  , (\_v16 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v16))) $ entitySet_metadata record
  , (\_v16 -> P.Just (3, ("entityList",T.TList (T.T_STRUCT typemap_Entity) $ P.map (\_v18 -> from_Entity _v18) $ Vector.toList _v16))) $ entitySet_entityList record
  , (\_v16 -> (4, ("linkingList",T.TList (T.T_STRUCT Linking_Types.typemap_Linking) $ P.map (\_v20 -> Linking_Types.from_Linking _v20) $ Vector.toList _v16))) <$> entitySet_linkingList record
  , (\_v16 -> (5, ("mentionSetId",Uuid_Types.from_UUID _v16))) <$> entitySet_mentionSetId record
  ]
write_EntitySet :: (T.Protocol p, T.Transport t) => p t -> EntitySet -> P.IO ()
write_EntitySet oprot record = T.writeVal oprot $ from_EntitySet record
encode_EntitySet :: (T.Protocol p, T.Transport t) => p t -> EntitySet -> LBS.ByteString
encode_EntitySet oprot record = T.serializeVal oprot $ from_EntitySet record
to_EntitySet :: T.ThriftVal -> EntitySet
to_EntitySet (T.TStruct fields) = EntitySet{
  entitySet_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val22) -> (case _val22 of {T.TStruct _val23 -> (Uuid_Types.to_UUID (T.TStruct _val23)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  entitySet_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val22) -> (case _val22 of {T.TStruct _val24 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val24)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  entitySet_entityList = P.maybe (P.error "Missing required field: entityList") (\(_,_val22) -> (case _val22 of {T.TList _ _val25 -> (Vector.fromList $ P.map (\_v26 -> (case _v26 of {T.TStruct _val27 -> (to_Entity (T.TStruct _val27)); _ -> P.error "wrong type"})) _val25); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  entitySet_linkingList = P.maybe (P.Nothing) (\(_,_val22) -> P.Just (case _val22 of {T.TList _ _val28 -> (Vector.fromList $ P.map (\_v29 -> (case _v29 of {T.TStruct _val30 -> (Linking_Types.to_Linking (T.TStruct _val30)); _ -> P.error "wrong type"})) _val28); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  entitySet_mentionSetId = P.maybe (P.Nothing) (\(_,_val22) -> P.Just (case _val22 of {T.TStruct _val31 -> (Uuid_Types.to_UUID (T.TStruct _val31)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_EntitySet _ = P.error "not a struct"
read_EntitySet :: (T.Transport t, T.Protocol p) => p t -> P.IO EntitySet
read_EntitySet iprot = to_EntitySet <$> T.readVal iprot (T.T_STRUCT typemap_EntitySet)
decode_EntitySet :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EntitySet
decode_EntitySet iprot bs = to_EntitySet $ T.deserializeVal iprot (T.T_STRUCT typemap_EntitySet) bs
typemap_EntitySet :: T.TypeMap
typemap_EntitySet = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("entityList",(T.T_LIST (T.T_STRUCT typemap_Entity)))),(4,("linkingList",(T.T_LIST (T.T_STRUCT Linking_Types.typemap_Linking)))),(5,("mentionSetId",(T.T_STRUCT Uuid_Types.typemap_UUID)))]
default_EntitySet :: EntitySet
default_EntitySet = EntitySet{
  entitySet_uuid = Uuid_Types.default_UUID,
  entitySet_metadata = Metadata_Types.default_AnnotationMetadata,
  entitySet_entityList = Vector.empty,
  entitySet_linkingList = P.Nothing,
  entitySet_mentionSetId = P.Nothing}
data EntityMention = EntityMention  { entityMention_uuid :: Uuid_Types.UUID
  , entityMention_tokens :: Structure_Types.TokenRefSequence
  , entityMention_entityType :: P.Maybe LT.Text
  , entityMention_phraseType :: P.Maybe LT.Text
  , entityMention_confidence :: P.Maybe P.Double
  , entityMention_text :: P.Maybe LT.Text
  , entityMention_childMentionIdList :: P.Maybe (Vector.Vector Uuid_Types.UUID)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EntityMention where
  hashWithSalt salt record = salt   `H.hashWithSalt` entityMention_uuid record   `H.hashWithSalt` entityMention_tokens record   `H.hashWithSalt` entityMention_entityType record   `H.hashWithSalt` entityMention_phraseType record   `H.hashWithSalt` entityMention_confidence record   `H.hashWithSalt` entityMention_text record   `H.hashWithSalt` entityMention_childMentionIdList record  
instance QC.Arbitrary EntityMention where 
  arbitrary = M.liftM EntityMention (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_EntityMention = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EntityMention{entityMention_uuid = entityMention_uuid obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_uuid = entityMention_uuid obj}
    , if obj == default_EntityMention{entityMention_tokens = entityMention_tokens obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_tokens = entityMention_tokens obj}
    , if obj == default_EntityMention{entityMention_entityType = entityMention_entityType obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_entityType = entityMention_entityType obj}
    , if obj == default_EntityMention{entityMention_phraseType = entityMention_phraseType obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_phraseType = entityMention_phraseType obj}
    , if obj == default_EntityMention{entityMention_confidence = entityMention_confidence obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_confidence = entityMention_confidence obj}
    , if obj == default_EntityMention{entityMention_text = entityMention_text obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_text = entityMention_text obj}
    , if obj == default_EntityMention{entityMention_childMentionIdList = entityMention_childMentionIdList obj} then P.Nothing else P.Just $ default_EntityMention{entityMention_childMentionIdList = entityMention_childMentionIdList obj}
    ]
from_EntityMention :: EntityMention -> T.ThriftVal
from_EntityMention record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v34 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v34))) $ entityMention_uuid record
  , (\_v34 -> P.Just (2, ("tokens",Structure_Types.from_TokenRefSequence _v34))) $ entityMention_tokens record
  , (\_v34 -> (3, ("entityType",T.TString $ E.encodeUtf8 _v34))) <$> entityMention_entityType record
  , (\_v34 -> (4, ("phraseType",T.TString $ E.encodeUtf8 _v34))) <$> entityMention_phraseType record
  , (\_v34 -> (5, ("confidence",T.TDouble _v34))) <$> entityMention_confidence record
  , (\_v34 -> (6, ("text",T.TString $ E.encodeUtf8 _v34))) <$> entityMention_text record
  , (\_v34 -> (7, ("childMentionIdList",T.TList (T.T_STRUCT Uuid_Types.typemap_UUID) $ P.map (\_v36 -> Uuid_Types.from_UUID _v36) $ Vector.toList _v34))) <$> entityMention_childMentionIdList record
  ]
write_EntityMention :: (T.Protocol p, T.Transport t) => p t -> EntityMention -> P.IO ()
write_EntityMention oprot record = T.writeVal oprot $ from_EntityMention record
encode_EntityMention :: (T.Protocol p, T.Transport t) => p t -> EntityMention -> LBS.ByteString
encode_EntityMention oprot record = T.serializeVal oprot $ from_EntityMention record
to_EntityMention :: T.ThriftVal -> EntityMention
to_EntityMention (T.TStruct fields) = EntityMention{
  entityMention_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val38) -> (case _val38 of {T.TStruct _val39 -> (Uuid_Types.to_UUID (T.TStruct _val39)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  entityMention_tokens = P.maybe (P.error "Missing required field: tokens") (\(_,_val38) -> (case _val38 of {T.TStruct _val40 -> (Structure_Types.to_TokenRefSequence (T.TStruct _val40)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  entityMention_entityType = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TString _val41 -> E.decodeUtf8 _val41; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  entityMention_phraseType = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TString _val42 -> E.decodeUtf8 _val42; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  entityMention_confidence = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TDouble _val43 -> _val43; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  entityMention_text = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TString _val44 -> E.decodeUtf8 _val44; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  entityMention_childMentionIdList = P.maybe (P.Nothing) (\(_,_val38) -> P.Just (case _val38 of {T.TList _ _val45 -> (Vector.fromList $ P.map (\_v46 -> (case _v46 of {T.TStruct _val47 -> (Uuid_Types.to_UUID (T.TStruct _val47)); _ -> P.error "wrong type"})) _val45); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_EntityMention _ = P.error "not a struct"
read_EntityMention :: (T.Transport t, T.Protocol p) => p t -> P.IO EntityMention
read_EntityMention iprot = to_EntityMention <$> T.readVal iprot (T.T_STRUCT typemap_EntityMention)
decode_EntityMention :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EntityMention
decode_EntityMention iprot bs = to_EntityMention $ T.deserializeVal iprot (T.T_STRUCT typemap_EntityMention) bs
typemap_EntityMention :: T.TypeMap
typemap_EntityMention = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("tokens",(T.T_STRUCT Structure_Types.typemap_TokenRefSequence))),(3,("entityType",T.T_STRING)),(4,("phraseType",T.T_STRING)),(5,("confidence",T.T_DOUBLE)),(6,("text",T.T_STRING)),(7,("childMentionIdList",(T.T_LIST (T.T_STRUCT Uuid_Types.typemap_UUID))))]
default_EntityMention :: EntityMention
default_EntityMention = EntityMention{
  entityMention_uuid = Uuid_Types.default_UUID,
  entityMention_tokens = Structure_Types.default_TokenRefSequence,
  entityMention_entityType = P.Nothing,
  entityMention_phraseType = P.Nothing,
  entityMention_confidence = P.Nothing,
  entityMention_text = P.Nothing,
  entityMention_childMentionIdList = P.Nothing}
data EntityMentionSet = EntityMentionSet  { entityMentionSet_uuid :: Uuid_Types.UUID
  , entityMentionSet_metadata :: Metadata_Types.AnnotationMetadata
  , entityMentionSet_mentionList :: (Vector.Vector EntityMention)
  , entityMentionSet_linkingList :: P.Maybe (Vector.Vector Linking_Types.Linking)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EntityMentionSet where
  hashWithSalt salt record = salt   `H.hashWithSalt` entityMentionSet_uuid record   `H.hashWithSalt` entityMentionSet_metadata record   `H.hashWithSalt` entityMentionSet_mentionList record   `H.hashWithSalt` entityMentionSet_linkingList record  
instance QC.Arbitrary EntityMentionSet where 
  arbitrary = M.liftM EntityMentionSet (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_EntityMentionSet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EntityMentionSet{entityMentionSet_uuid = entityMentionSet_uuid obj} then P.Nothing else P.Just $ default_EntityMentionSet{entityMentionSet_uuid = entityMentionSet_uuid obj}
    , if obj == default_EntityMentionSet{entityMentionSet_metadata = entityMentionSet_metadata obj} then P.Nothing else P.Just $ default_EntityMentionSet{entityMentionSet_metadata = entityMentionSet_metadata obj}
    , if obj == default_EntityMentionSet{entityMentionSet_mentionList = entityMentionSet_mentionList obj} then P.Nothing else P.Just $ default_EntityMentionSet{entityMentionSet_mentionList = entityMentionSet_mentionList obj}
    , if obj == default_EntityMentionSet{entityMentionSet_linkingList = entityMentionSet_linkingList obj} then P.Nothing else P.Just $ default_EntityMentionSet{entityMentionSet_linkingList = entityMentionSet_linkingList obj}
    ]
from_EntityMentionSet :: EntityMentionSet -> T.ThriftVal
from_EntityMentionSet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v50 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v50))) $ entityMentionSet_uuid record
  , (\_v50 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v50))) $ entityMentionSet_metadata record
  , (\_v50 -> P.Just (3, ("mentionList",T.TList (T.T_STRUCT typemap_EntityMention) $ P.map (\_v52 -> from_EntityMention _v52) $ Vector.toList _v50))) $ entityMentionSet_mentionList record
  , (\_v50 -> (4, ("linkingList",T.TList (T.T_STRUCT Linking_Types.typemap_Linking) $ P.map (\_v54 -> Linking_Types.from_Linking _v54) $ Vector.toList _v50))) <$> entityMentionSet_linkingList record
  ]
write_EntityMentionSet :: (T.Protocol p, T.Transport t) => p t -> EntityMentionSet -> P.IO ()
write_EntityMentionSet oprot record = T.writeVal oprot $ from_EntityMentionSet record
encode_EntityMentionSet :: (T.Protocol p, T.Transport t) => p t -> EntityMentionSet -> LBS.ByteString
encode_EntityMentionSet oprot record = T.serializeVal oprot $ from_EntityMentionSet record
to_EntityMentionSet :: T.ThriftVal -> EntityMentionSet
to_EntityMentionSet (T.TStruct fields) = EntityMentionSet{
  entityMentionSet_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val56) -> (case _val56 of {T.TStruct _val57 -> (Uuid_Types.to_UUID (T.TStruct _val57)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  entityMentionSet_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val56) -> (case _val56 of {T.TStruct _val58 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val58)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  entityMentionSet_mentionList = P.maybe (P.error "Missing required field: mentionList") (\(_,_val56) -> (case _val56 of {T.TList _ _val59 -> (Vector.fromList $ P.map (\_v60 -> (case _v60 of {T.TStruct _val61 -> (to_EntityMention (T.TStruct _val61)); _ -> P.error "wrong type"})) _val59); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  entityMentionSet_linkingList = P.maybe (P.Nothing) (\(_,_val56) -> P.Just (case _val56 of {T.TList _ _val62 -> (Vector.fromList $ P.map (\_v63 -> (case _v63 of {T.TStruct _val64 -> (Linking_Types.to_Linking (T.TStruct _val64)); _ -> P.error "wrong type"})) _val62); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_EntityMentionSet _ = P.error "not a struct"
read_EntityMentionSet :: (T.Transport t, T.Protocol p) => p t -> P.IO EntityMentionSet
read_EntityMentionSet iprot = to_EntityMentionSet <$> T.readVal iprot (T.T_STRUCT typemap_EntityMentionSet)
decode_EntityMentionSet :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> EntityMentionSet
decode_EntityMentionSet iprot bs = to_EntityMentionSet $ T.deserializeVal iprot (T.T_STRUCT typemap_EntityMentionSet) bs
typemap_EntityMentionSet :: T.TypeMap
typemap_EntityMentionSet = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("mentionList",(T.T_LIST (T.T_STRUCT typemap_EntityMention)))),(4,("linkingList",(T.T_LIST (T.T_STRUCT Linking_Types.typemap_Linking))))]
default_EntityMentionSet :: EntityMentionSet
default_EntityMentionSet = EntityMentionSet{
  entityMentionSet_uuid = Uuid_Types.default_UUID,
  entityMentionSet_metadata = Metadata_Types.default_AnnotationMetadata,
  entityMentionSet_mentionList = Vector.empty,
  entityMentionSet_linkingList = P.Nothing}
