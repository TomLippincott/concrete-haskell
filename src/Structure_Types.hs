{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.10.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Structure_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import qualified Metadata_Types
import qualified Spans_Types
import qualified Uuid_Types
import qualified Language_Types


data TokenizationKind = TOKEN_LIST|TOKEN_LATTICE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum TokenizationKind where
  fromEnum t = case t of
    TOKEN_LIST -> 1
    TOKEN_LATTICE -> 2
  toEnum t = case t of
    1 -> TOKEN_LIST
    2 -> TOKEN_LATTICE
    _ -> X.throw T.ThriftException
instance H.Hashable TokenizationKind where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary TokenizationKind where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data Token = Token  { token_tokenIndex :: I.Int32
  , token_text :: P.Maybe LT.Text
  , token_textSpan :: P.Maybe Spans_Types.TextSpan
  , token_rawTextSpan :: P.Maybe Spans_Types.TextSpan
  , token_audioSpan :: P.Maybe Spans_Types.AudioSpan
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Token where
  hashWithSalt salt record = salt   `H.hashWithSalt` token_tokenIndex record   `H.hashWithSalt` token_text record   `H.hashWithSalt` token_textSpan record   `H.hashWithSalt` token_rawTextSpan record   `H.hashWithSalt` token_audioSpan record  
instance QC.Arbitrary Token where 
  arbitrary = M.liftM Token (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Token = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Token{token_tokenIndex = token_tokenIndex obj} then P.Nothing else P.Just $ default_Token{token_tokenIndex = token_tokenIndex obj}
    , if obj == default_Token{token_text = token_text obj} then P.Nothing else P.Just $ default_Token{token_text = token_text obj}
    , if obj == default_Token{token_textSpan = token_textSpan obj} then P.Nothing else P.Just $ default_Token{token_textSpan = token_textSpan obj}
    , if obj == default_Token{token_rawTextSpan = token_rawTextSpan obj} then P.Nothing else P.Just $ default_Token{token_rawTextSpan = token_rawTextSpan obj}
    , if obj == default_Token{token_audioSpan = token_audioSpan obj} then P.Nothing else P.Just $ default_Token{token_audioSpan = token_audioSpan obj}
    ]
from_Token :: Token -> T.ThriftVal
from_Token record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("tokenIndex",T.TI32 _v2))) $ token_tokenIndex record
  , (\_v2 -> (2, ("text",T.TString $ E.encodeUtf8 _v2))) <$> token_text record
  , (\_v2 -> (3, ("textSpan",Spans_Types.from_TextSpan _v2))) <$> token_textSpan record
  , (\_v2 -> (4, ("rawTextSpan",Spans_Types.from_TextSpan _v2))) <$> token_rawTextSpan record
  , (\_v2 -> (5, ("audioSpan",Spans_Types.from_AudioSpan _v2))) <$> token_audioSpan record
  ]
write_Token :: (T.Protocol p, T.Transport t) => p t -> Token -> P.IO ()
write_Token oprot record = T.writeVal oprot $ from_Token record
encode_Token :: (T.Protocol p, T.Transport t) => p t -> Token -> LBS.ByteString
encode_Token oprot record = T.serializeVal oprot $ from_Token record
to_Token :: T.ThriftVal -> Token
to_Token (T.TStruct fields) = Token{
  token_tokenIndex = P.maybe (P.error "Missing required field: tokenIndex") (\(_,_val4) -> (case _val4 of {T.TI32 _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  token_text = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val6 -> E.decodeUtf8 _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  token_textSpan = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TStruct _val7 -> (Spans_Types.to_TextSpan (T.TStruct _val7)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  token_rawTextSpan = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TStruct _val8 -> (Spans_Types.to_TextSpan (T.TStruct _val8)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  token_audioSpan = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TStruct _val9 -> (Spans_Types.to_AudioSpan (T.TStruct _val9)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Token _ = P.error "not a struct"
read_Token :: (T.Transport t, T.Protocol p) => p t -> P.IO Token
read_Token iprot = to_Token <$> T.readVal iprot (T.T_STRUCT typemap_Token)
decode_Token :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Token
decode_Token iprot bs = to_Token $ T.deserializeVal iprot (T.T_STRUCT typemap_Token) bs
typemap_Token :: T.TypeMap
typemap_Token = Map.fromList [(1,("tokenIndex",T.T_I32)),(2,("text",T.T_STRING)),(3,("textSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(4,("rawTextSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(5,("audioSpan",(T.T_STRUCT Spans_Types.typemap_AudioSpan)))]
default_Token :: Token
default_Token = Token{
  token_tokenIndex = 0,
  token_text = P.Nothing,
  token_textSpan = P.Nothing,
  token_rawTextSpan = P.Nothing,
  token_audioSpan = P.Nothing}
data ConstituentRef = ConstituentRef  { constituentRef_parseId :: Uuid_Types.UUID
  , constituentRef_constituentIndex :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConstituentRef where
  hashWithSalt salt record = salt   `H.hashWithSalt` constituentRef_parseId record   `H.hashWithSalt` constituentRef_constituentIndex record  
instance QC.Arbitrary ConstituentRef where 
  arbitrary = M.liftM ConstituentRef (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ConstituentRef = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConstituentRef{constituentRef_parseId = constituentRef_parseId obj} then P.Nothing else P.Just $ default_ConstituentRef{constituentRef_parseId = constituentRef_parseId obj}
    , if obj == default_ConstituentRef{constituentRef_constituentIndex = constituentRef_constituentIndex obj} then P.Nothing else P.Just $ default_ConstituentRef{constituentRef_constituentIndex = constituentRef_constituentIndex obj}
    ]
from_ConstituentRef :: ConstituentRef -> T.ThriftVal
from_ConstituentRef record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v12 -> P.Just (1, ("parseId",Uuid_Types.from_UUID _v12))) $ constituentRef_parseId record
  , (\_v12 -> P.Just (2, ("constituentIndex",T.TI32 _v12))) $ constituentRef_constituentIndex record
  ]
write_ConstituentRef :: (T.Protocol p, T.Transport t) => p t -> ConstituentRef -> P.IO ()
write_ConstituentRef oprot record = T.writeVal oprot $ from_ConstituentRef record
encode_ConstituentRef :: (T.Protocol p, T.Transport t) => p t -> ConstituentRef -> LBS.ByteString
encode_ConstituentRef oprot record = T.serializeVal oprot $ from_ConstituentRef record
to_ConstituentRef :: T.ThriftVal -> ConstituentRef
to_ConstituentRef (T.TStruct fields) = ConstituentRef{
  constituentRef_parseId = P.maybe (P.error "Missing required field: parseId") (\(_,_val14) -> (case _val14 of {T.TStruct _val15 -> (Uuid_Types.to_UUID (T.TStruct _val15)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  constituentRef_constituentIndex = P.maybe (P.error "Missing required field: constituentIndex") (\(_,_val14) -> (case _val14 of {T.TI32 _val16 -> _val16; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ConstituentRef _ = P.error "not a struct"
read_ConstituentRef :: (T.Transport t, T.Protocol p) => p t -> P.IO ConstituentRef
read_ConstituentRef iprot = to_ConstituentRef <$> T.readVal iprot (T.T_STRUCT typemap_ConstituentRef)
decode_ConstituentRef :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ConstituentRef
decode_ConstituentRef iprot bs = to_ConstituentRef $ T.deserializeVal iprot (T.T_STRUCT typemap_ConstituentRef) bs
typemap_ConstituentRef :: T.TypeMap
typemap_ConstituentRef = Map.fromList [(1,("parseId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("constituentIndex",T.T_I32))]
default_ConstituentRef :: ConstituentRef
default_ConstituentRef = ConstituentRef{
  constituentRef_parseId = Uuid_Types.default_UUID,
  constituentRef_constituentIndex = 0}
data TokenRefSequence = TokenRefSequence  { tokenRefSequence_tokenIndexList :: (Vector.Vector I.Int32)
  , tokenRefSequence_anchorTokenIndex :: P.Maybe I.Int32
  , tokenRefSequence_tokenizationId :: Uuid_Types.UUID
  , tokenRefSequence_textSpan :: P.Maybe Spans_Types.TextSpan
  , tokenRefSequence_rawTextSpan :: P.Maybe Spans_Types.TextSpan
  , tokenRefSequence_audioSpan :: P.Maybe Spans_Types.AudioSpan
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TokenRefSequence where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenRefSequence_tokenIndexList record   `H.hashWithSalt` tokenRefSequence_anchorTokenIndex record   `H.hashWithSalt` tokenRefSequence_tokenizationId record   `H.hashWithSalt` tokenRefSequence_textSpan record   `H.hashWithSalt` tokenRefSequence_rawTextSpan record   `H.hashWithSalt` tokenRefSequence_audioSpan record  
instance QC.Arbitrary TokenRefSequence where 
  arbitrary = M.liftM TokenRefSequence (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TokenRefSequence = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TokenRefSequence{tokenRefSequence_tokenIndexList = tokenRefSequence_tokenIndexList obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_tokenIndexList = tokenRefSequence_tokenIndexList obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_anchorTokenIndex = tokenRefSequence_anchorTokenIndex obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_anchorTokenIndex = tokenRefSequence_anchorTokenIndex obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_tokenizationId = tokenRefSequence_tokenizationId obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_tokenizationId = tokenRefSequence_tokenizationId obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_textSpan = tokenRefSequence_textSpan obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_textSpan = tokenRefSequence_textSpan obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_rawTextSpan = tokenRefSequence_rawTextSpan obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_rawTextSpan = tokenRefSequence_rawTextSpan obj}
    , if obj == default_TokenRefSequence{tokenRefSequence_audioSpan = tokenRefSequence_audioSpan obj} then P.Nothing else P.Just $ default_TokenRefSequence{tokenRefSequence_audioSpan = tokenRefSequence_audioSpan obj}
    ]
from_TokenRefSequence :: TokenRefSequence -> T.ThriftVal
from_TokenRefSequence record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v19 -> P.Just (1, ("tokenIndexList",T.TList T.T_I32 $ P.map (\_v21 -> T.TI32 _v21) $ Vector.toList _v19))) $ tokenRefSequence_tokenIndexList record
  , (\_v19 -> (2, ("anchorTokenIndex",T.TI32 _v19))) <$> tokenRefSequence_anchorTokenIndex record
  , (\_v19 -> P.Just (3, ("tokenizationId",Uuid_Types.from_UUID _v19))) $ tokenRefSequence_tokenizationId record
  , (\_v19 -> (4, ("textSpan",Spans_Types.from_TextSpan _v19))) <$> tokenRefSequence_textSpan record
  , (\_v19 -> (5, ("rawTextSpan",Spans_Types.from_TextSpan _v19))) <$> tokenRefSequence_rawTextSpan record
  , (\_v19 -> (6, ("audioSpan",Spans_Types.from_AudioSpan _v19))) <$> tokenRefSequence_audioSpan record
  ]
write_TokenRefSequence :: (T.Protocol p, T.Transport t) => p t -> TokenRefSequence -> P.IO ()
write_TokenRefSequence oprot record = T.writeVal oprot $ from_TokenRefSequence record
encode_TokenRefSequence :: (T.Protocol p, T.Transport t) => p t -> TokenRefSequence -> LBS.ByteString
encode_TokenRefSequence oprot record = T.serializeVal oprot $ from_TokenRefSequence record
to_TokenRefSequence :: T.ThriftVal -> TokenRefSequence
to_TokenRefSequence (T.TStruct fields) = TokenRefSequence{
  tokenRefSequence_tokenIndexList = P.maybe (P.error "Missing required field: tokenIndexList") (\(_,_val23) -> (case _val23 of {T.TList _ _val24 -> (Vector.fromList $ P.map (\_v25 -> (case _v25 of {T.TI32 _val26 -> _val26; _ -> P.error "wrong type"})) _val24); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tokenRefSequence_anchorTokenIndex = P.maybe (tokenRefSequence_anchorTokenIndex default_TokenRefSequence) (\(_,_val23) -> P.Just (case _val23 of {T.TI32 _val27 -> _val27; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tokenRefSequence_tokenizationId = P.maybe (P.error "Missing required field: tokenizationId") (\(_,_val23) -> (case _val23 of {T.TStruct _val28 -> (Uuid_Types.to_UUID (T.TStruct _val28)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tokenRefSequence_textSpan = P.maybe (P.Nothing) (\(_,_val23) -> P.Just (case _val23 of {T.TStruct _val29 -> (Spans_Types.to_TextSpan (T.TStruct _val29)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  tokenRefSequence_rawTextSpan = P.maybe (P.Nothing) (\(_,_val23) -> P.Just (case _val23 of {T.TStruct _val30 -> (Spans_Types.to_TextSpan (T.TStruct _val30)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  tokenRefSequence_audioSpan = P.maybe (P.Nothing) (\(_,_val23) -> P.Just (case _val23 of {T.TStruct _val31 -> (Spans_Types.to_AudioSpan (T.TStruct _val31)); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_TokenRefSequence _ = P.error "not a struct"
read_TokenRefSequence :: (T.Transport t, T.Protocol p) => p t -> P.IO TokenRefSequence
read_TokenRefSequence iprot = to_TokenRefSequence <$> T.readVal iprot (T.T_STRUCT typemap_TokenRefSequence)
decode_TokenRefSequence :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TokenRefSequence
decode_TokenRefSequence iprot bs = to_TokenRefSequence $ T.deserializeVal iprot (T.T_STRUCT typemap_TokenRefSequence) bs
typemap_TokenRefSequence :: T.TypeMap
typemap_TokenRefSequence = Map.fromList [(1,("tokenIndexList",(T.T_LIST T.T_I32))),(2,("anchorTokenIndex",T.T_I32)),(3,("tokenizationId",(T.T_STRUCT Uuid_Types.typemap_UUID))),(4,("textSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(5,("rawTextSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(6,("audioSpan",(T.T_STRUCT Spans_Types.typemap_AudioSpan)))]
default_TokenRefSequence :: TokenRefSequence
default_TokenRefSequence = TokenRefSequence{
  tokenRefSequence_tokenIndexList = Vector.empty,
  tokenRefSequence_anchorTokenIndex = P.Just (-1),
  tokenRefSequence_tokenizationId = Uuid_Types.default_UUID,
  tokenRefSequence_textSpan = P.Nothing,
  tokenRefSequence_rawTextSpan = P.Nothing,
  tokenRefSequence_audioSpan = P.Nothing}
data TaggedToken = TaggedToken  { taggedToken_tokenIndex :: P.Maybe I.Int32
  , taggedToken_tag :: P.Maybe LT.Text
  , taggedToken_confidence :: P.Maybe P.Double
  , taggedToken_tagList :: P.Maybe (Vector.Vector LT.Text)
  , taggedToken_confidenceList :: P.Maybe (Vector.Vector P.Double)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TaggedToken where
  hashWithSalt salt record = salt   `H.hashWithSalt` taggedToken_tokenIndex record   `H.hashWithSalt` taggedToken_tag record   `H.hashWithSalt` taggedToken_confidence record   `H.hashWithSalt` taggedToken_tagList record   `H.hashWithSalt` taggedToken_confidenceList record  
instance QC.Arbitrary TaggedToken where 
  arbitrary = M.liftM TaggedToken (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TaggedToken = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TaggedToken{taggedToken_tokenIndex = taggedToken_tokenIndex obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_tokenIndex = taggedToken_tokenIndex obj}
    , if obj == default_TaggedToken{taggedToken_tag = taggedToken_tag obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_tag = taggedToken_tag obj}
    , if obj == default_TaggedToken{taggedToken_confidence = taggedToken_confidence obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_confidence = taggedToken_confidence obj}
    , if obj == default_TaggedToken{taggedToken_tagList = taggedToken_tagList obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_tagList = taggedToken_tagList obj}
    , if obj == default_TaggedToken{taggedToken_confidenceList = taggedToken_confidenceList obj} then P.Nothing else P.Just $ default_TaggedToken{taggedToken_confidenceList = taggedToken_confidenceList obj}
    ]
from_TaggedToken :: TaggedToken -> T.ThriftVal
from_TaggedToken record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v34 -> (1, ("tokenIndex",T.TI32 _v34))) <$> taggedToken_tokenIndex record
  , (\_v34 -> (2, ("tag",T.TString $ E.encodeUtf8 _v34))) <$> taggedToken_tag record
  , (\_v34 -> (3, ("confidence",T.TDouble _v34))) <$> taggedToken_confidence record
  , (\_v34 -> (4, ("tagList",T.TList T.T_STRING $ P.map (\_v36 -> T.TString $ E.encodeUtf8 _v36) $ Vector.toList _v34))) <$> taggedToken_tagList record
  , (\_v34 -> (5, ("confidenceList",T.TList T.T_DOUBLE $ P.map (\_v38 -> T.TDouble _v38) $ Vector.toList _v34))) <$> taggedToken_confidenceList record
  ]
write_TaggedToken :: (T.Protocol p, T.Transport t) => p t -> TaggedToken -> P.IO ()
write_TaggedToken oprot record = T.writeVal oprot $ from_TaggedToken record
encode_TaggedToken :: (T.Protocol p, T.Transport t) => p t -> TaggedToken -> LBS.ByteString
encode_TaggedToken oprot record = T.serializeVal oprot $ from_TaggedToken record
to_TaggedToken :: T.ThriftVal -> TaggedToken
to_TaggedToken (T.TStruct fields) = TaggedToken{
  taggedToken_tokenIndex = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TI32 _val41 -> _val41; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  taggedToken_tag = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TString _val42 -> E.decodeUtf8 _val42; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  taggedToken_confidence = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TDouble _val43 -> _val43; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  taggedToken_tagList = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TList _ _val44 -> (Vector.fromList $ P.map (\_v45 -> (case _v45 of {T.TString _val46 -> E.decodeUtf8 _val46; _ -> P.error "wrong type"})) _val44); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  taggedToken_confidenceList = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TList _ _val47 -> (Vector.fromList $ P.map (\_v48 -> (case _v48 of {T.TDouble _val49 -> _val49; _ -> P.error "wrong type"})) _val47); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_TaggedToken _ = P.error "not a struct"
read_TaggedToken :: (T.Transport t, T.Protocol p) => p t -> P.IO TaggedToken
read_TaggedToken iprot = to_TaggedToken <$> T.readVal iprot (T.T_STRUCT typemap_TaggedToken)
decode_TaggedToken :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TaggedToken
decode_TaggedToken iprot bs = to_TaggedToken $ T.deserializeVal iprot (T.T_STRUCT typemap_TaggedToken) bs
typemap_TaggedToken :: T.TypeMap
typemap_TaggedToken = Map.fromList [(1,("tokenIndex",T.T_I32)),(2,("tag",T.T_STRING)),(3,("confidence",T.T_DOUBLE)),(4,("tagList",(T.T_LIST T.T_STRING))),(5,("confidenceList",(T.T_LIST T.T_DOUBLE)))]
default_TaggedToken :: TaggedToken
default_TaggedToken = TaggedToken{
  taggedToken_tokenIndex = P.Nothing,
  taggedToken_tag = P.Nothing,
  taggedToken_confidence = P.Nothing,
  taggedToken_tagList = P.Nothing,
  taggedToken_confidenceList = P.Nothing}
data TokenTagging = TokenTagging  { tokenTagging_uuid :: Uuid_Types.UUID
  , tokenTagging_metadata :: Metadata_Types.AnnotationMetadata
  , tokenTagging_taggedTokenList :: (Vector.Vector TaggedToken)
  , tokenTagging_taggingType :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TokenTagging where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenTagging_uuid record   `H.hashWithSalt` tokenTagging_metadata record   `H.hashWithSalt` tokenTagging_taggedTokenList record   `H.hashWithSalt` tokenTagging_taggingType record  
instance QC.Arbitrary TokenTagging where 
  arbitrary = M.liftM TokenTagging (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TokenTagging = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TokenTagging{tokenTagging_uuid = tokenTagging_uuid obj} then P.Nothing else P.Just $ default_TokenTagging{tokenTagging_uuid = tokenTagging_uuid obj}
    , if obj == default_TokenTagging{tokenTagging_metadata = tokenTagging_metadata obj} then P.Nothing else P.Just $ default_TokenTagging{tokenTagging_metadata = tokenTagging_metadata obj}
    , if obj == default_TokenTagging{tokenTagging_taggedTokenList = tokenTagging_taggedTokenList obj} then P.Nothing else P.Just $ default_TokenTagging{tokenTagging_taggedTokenList = tokenTagging_taggedTokenList obj}
    , if obj == default_TokenTagging{tokenTagging_taggingType = tokenTagging_taggingType obj} then P.Nothing else P.Just $ default_TokenTagging{tokenTagging_taggingType = tokenTagging_taggingType obj}
    ]
from_TokenTagging :: TokenTagging -> T.ThriftVal
from_TokenTagging record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v52 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v52))) $ tokenTagging_uuid record
  , (\_v52 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v52))) $ tokenTagging_metadata record
  , (\_v52 -> P.Just (3, ("taggedTokenList",T.TList (T.T_STRUCT typemap_TaggedToken) $ P.map (\_v54 -> from_TaggedToken _v54) $ Vector.toList _v52))) $ tokenTagging_taggedTokenList record
  , (\_v52 -> (4, ("taggingType",T.TString $ E.encodeUtf8 _v52))) <$> tokenTagging_taggingType record
  ]
write_TokenTagging :: (T.Protocol p, T.Transport t) => p t -> TokenTagging -> P.IO ()
write_TokenTagging oprot record = T.writeVal oprot $ from_TokenTagging record
encode_TokenTagging :: (T.Protocol p, T.Transport t) => p t -> TokenTagging -> LBS.ByteString
encode_TokenTagging oprot record = T.serializeVal oprot $ from_TokenTagging record
to_TokenTagging :: T.ThriftVal -> TokenTagging
to_TokenTagging (T.TStruct fields) = TokenTagging{
  tokenTagging_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val56) -> (case _val56 of {T.TStruct _val57 -> (Uuid_Types.to_UUID (T.TStruct _val57)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tokenTagging_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val56) -> (case _val56 of {T.TStruct _val58 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val58)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tokenTagging_taggedTokenList = P.maybe (P.error "Missing required field: taggedTokenList") (\(_,_val56) -> (case _val56 of {T.TList _ _val59 -> (Vector.fromList $ P.map (\_v60 -> (case _v60 of {T.TStruct _val61 -> (to_TaggedToken (T.TStruct _val61)); _ -> P.error "wrong type"})) _val59); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tokenTagging_taggingType = P.maybe (P.Nothing) (\(_,_val56) -> P.Just (case _val56 of {T.TString _val62 -> E.decodeUtf8 _val62; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TokenTagging _ = P.error "not a struct"
read_TokenTagging :: (T.Transport t, T.Protocol p) => p t -> P.IO TokenTagging
read_TokenTagging iprot = to_TokenTagging <$> T.readVal iprot (T.T_STRUCT typemap_TokenTagging)
decode_TokenTagging :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TokenTagging
decode_TokenTagging iprot bs = to_TokenTagging $ T.deserializeVal iprot (T.T_STRUCT typemap_TokenTagging) bs
typemap_TokenTagging :: T.TypeMap
typemap_TokenTagging = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("taggedTokenList",(T.T_LIST (T.T_STRUCT typemap_TaggedToken)))),(4,("taggingType",T.T_STRING))]
default_TokenTagging :: TokenTagging
default_TokenTagging = TokenTagging{
  tokenTagging_uuid = Uuid_Types.default_UUID,
  tokenTagging_metadata = Metadata_Types.default_AnnotationMetadata,
  tokenTagging_taggedTokenList = Vector.empty,
  tokenTagging_taggingType = P.Nothing}
data Dependency = Dependency  { dependency_gov :: P.Maybe I.Int32
  , dependency_dep :: I.Int32
  , dependency_edgeType :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Dependency where
  hashWithSalt salt record = salt   `H.hashWithSalt` dependency_gov record   `H.hashWithSalt` dependency_dep record   `H.hashWithSalt` dependency_edgeType record  
instance QC.Arbitrary Dependency where 
  arbitrary = M.liftM Dependency (M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Dependency = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Dependency{dependency_gov = dependency_gov obj} then P.Nothing else P.Just $ default_Dependency{dependency_gov = dependency_gov obj}
    , if obj == default_Dependency{dependency_dep = dependency_dep obj} then P.Nothing else P.Just $ default_Dependency{dependency_dep = dependency_dep obj}
    , if obj == default_Dependency{dependency_edgeType = dependency_edgeType obj} then P.Nothing else P.Just $ default_Dependency{dependency_edgeType = dependency_edgeType obj}
    ]
from_Dependency :: Dependency -> T.ThriftVal
from_Dependency record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v65 -> (1, ("gov",T.TI32 _v65))) <$> dependency_gov record
  , (\_v65 -> P.Just (2, ("dep",T.TI32 _v65))) $ dependency_dep record
  , (\_v65 -> (3, ("edgeType",T.TString $ E.encodeUtf8 _v65))) <$> dependency_edgeType record
  ]
write_Dependency :: (T.Protocol p, T.Transport t) => p t -> Dependency -> P.IO ()
write_Dependency oprot record = T.writeVal oprot $ from_Dependency record
encode_Dependency :: (T.Protocol p, T.Transport t) => p t -> Dependency -> LBS.ByteString
encode_Dependency oprot record = T.serializeVal oprot $ from_Dependency record
to_Dependency :: T.ThriftVal -> Dependency
to_Dependency (T.TStruct fields) = Dependency{
  dependency_gov = P.maybe (dependency_gov default_Dependency) (\(_,_val67) -> P.Just (case _val67 of {T.TI32 _val68 -> _val68; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  dependency_dep = P.maybe (P.error "Missing required field: dep") (\(_,_val67) -> (case _val67 of {T.TI32 _val69 -> _val69; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  dependency_edgeType = P.maybe (P.Nothing) (\(_,_val67) -> P.Just (case _val67 of {T.TString _val70 -> E.decodeUtf8 _val70; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Dependency _ = P.error "not a struct"
read_Dependency :: (T.Transport t, T.Protocol p) => p t -> P.IO Dependency
read_Dependency iprot = to_Dependency <$> T.readVal iprot (T.T_STRUCT typemap_Dependency)
decode_Dependency :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Dependency
decode_Dependency iprot bs = to_Dependency $ T.deserializeVal iprot (T.T_STRUCT typemap_Dependency) bs
typemap_Dependency :: T.TypeMap
typemap_Dependency = Map.fromList [(1,("gov",T.T_I32)),(2,("dep",T.T_I32)),(3,("edgeType",T.T_STRING))]
default_Dependency :: Dependency
default_Dependency = Dependency{
  dependency_gov = P.Just (-1),
  dependency_dep = 0,
  dependency_edgeType = P.Nothing}
data DependencyParseStructure = DependencyParseStructure  { dependencyParseStructure_isAcyclic :: P.Bool
  , dependencyParseStructure_isConnected :: P.Bool
  , dependencyParseStructure_isSingleHeaded :: P.Bool
  , dependencyParseStructure_isProjective :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DependencyParseStructure where
  hashWithSalt salt record = salt   `H.hashWithSalt` dependencyParseStructure_isAcyclic record   `H.hashWithSalt` dependencyParseStructure_isConnected record   `H.hashWithSalt` dependencyParseStructure_isSingleHeaded record   `H.hashWithSalt` dependencyParseStructure_isProjective record  
instance QC.Arbitrary DependencyParseStructure where 
  arbitrary = M.liftM DependencyParseStructure (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DependencyParseStructure = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DependencyParseStructure{dependencyParseStructure_isAcyclic = dependencyParseStructure_isAcyclic obj} then P.Nothing else P.Just $ default_DependencyParseStructure{dependencyParseStructure_isAcyclic = dependencyParseStructure_isAcyclic obj}
    , if obj == default_DependencyParseStructure{dependencyParseStructure_isConnected = dependencyParseStructure_isConnected obj} then P.Nothing else P.Just $ default_DependencyParseStructure{dependencyParseStructure_isConnected = dependencyParseStructure_isConnected obj}
    , if obj == default_DependencyParseStructure{dependencyParseStructure_isSingleHeaded = dependencyParseStructure_isSingleHeaded obj} then P.Nothing else P.Just $ default_DependencyParseStructure{dependencyParseStructure_isSingleHeaded = dependencyParseStructure_isSingleHeaded obj}
    , if obj == default_DependencyParseStructure{dependencyParseStructure_isProjective = dependencyParseStructure_isProjective obj} then P.Nothing else P.Just $ default_DependencyParseStructure{dependencyParseStructure_isProjective = dependencyParseStructure_isProjective obj}
    ]
from_DependencyParseStructure :: DependencyParseStructure -> T.ThriftVal
from_DependencyParseStructure record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v73 -> P.Just (1, ("isAcyclic",T.TBool _v73))) $ dependencyParseStructure_isAcyclic record
  , (\_v73 -> P.Just (2, ("isConnected",T.TBool _v73))) $ dependencyParseStructure_isConnected record
  , (\_v73 -> P.Just (3, ("isSingleHeaded",T.TBool _v73))) $ dependencyParseStructure_isSingleHeaded record
  , (\_v73 -> P.Just (4, ("isProjective",T.TBool _v73))) $ dependencyParseStructure_isProjective record
  ]
write_DependencyParseStructure :: (T.Protocol p, T.Transport t) => p t -> DependencyParseStructure -> P.IO ()
write_DependencyParseStructure oprot record = T.writeVal oprot $ from_DependencyParseStructure record
encode_DependencyParseStructure :: (T.Protocol p, T.Transport t) => p t -> DependencyParseStructure -> LBS.ByteString
encode_DependencyParseStructure oprot record = T.serializeVal oprot $ from_DependencyParseStructure record
to_DependencyParseStructure :: T.ThriftVal -> DependencyParseStructure
to_DependencyParseStructure (T.TStruct fields) = DependencyParseStructure{
  dependencyParseStructure_isAcyclic = P.maybe (P.error "Missing required field: isAcyclic") (\(_,_val75) -> (case _val75 of {T.TBool _val76 -> _val76; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  dependencyParseStructure_isConnected = P.maybe (P.error "Missing required field: isConnected") (\(_,_val75) -> (case _val75 of {T.TBool _val77 -> _val77; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  dependencyParseStructure_isSingleHeaded = P.maybe (P.error "Missing required field: isSingleHeaded") (\(_,_val75) -> (case _val75 of {T.TBool _val78 -> _val78; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  dependencyParseStructure_isProjective = P.maybe (P.error "Missing required field: isProjective") (\(_,_val75) -> (case _val75 of {T.TBool _val79 -> _val79; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_DependencyParseStructure _ = P.error "not a struct"
read_DependencyParseStructure :: (T.Transport t, T.Protocol p) => p t -> P.IO DependencyParseStructure
read_DependencyParseStructure iprot = to_DependencyParseStructure <$> T.readVal iprot (T.T_STRUCT typemap_DependencyParseStructure)
decode_DependencyParseStructure :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DependencyParseStructure
decode_DependencyParseStructure iprot bs = to_DependencyParseStructure $ T.deserializeVal iprot (T.T_STRUCT typemap_DependencyParseStructure) bs
typemap_DependencyParseStructure :: T.TypeMap
typemap_DependencyParseStructure = Map.fromList [(1,("isAcyclic",T.T_BOOL)),(2,("isConnected",T.T_BOOL)),(3,("isSingleHeaded",T.T_BOOL)),(4,("isProjective",T.T_BOOL))]
default_DependencyParseStructure :: DependencyParseStructure
default_DependencyParseStructure = DependencyParseStructure{
  dependencyParseStructure_isAcyclic = P.False,
  dependencyParseStructure_isConnected = P.False,
  dependencyParseStructure_isSingleHeaded = P.False,
  dependencyParseStructure_isProjective = P.False}
data DependencyParse = DependencyParse  { dependencyParse_uuid :: Uuid_Types.UUID
  , dependencyParse_metadata :: Metadata_Types.AnnotationMetadata
  , dependencyParse_dependencyList :: (Vector.Vector Dependency)
  , dependencyParse_structureInformation :: P.Maybe DependencyParseStructure
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DependencyParse where
  hashWithSalt salt record = salt   `H.hashWithSalt` dependencyParse_uuid record   `H.hashWithSalt` dependencyParse_metadata record   `H.hashWithSalt` dependencyParse_dependencyList record   `H.hashWithSalt` dependencyParse_structureInformation record  
instance QC.Arbitrary DependencyParse where 
  arbitrary = M.liftM DependencyParse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DependencyParse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DependencyParse{dependencyParse_uuid = dependencyParse_uuid obj} then P.Nothing else P.Just $ default_DependencyParse{dependencyParse_uuid = dependencyParse_uuid obj}
    , if obj == default_DependencyParse{dependencyParse_metadata = dependencyParse_metadata obj} then P.Nothing else P.Just $ default_DependencyParse{dependencyParse_metadata = dependencyParse_metadata obj}
    , if obj == default_DependencyParse{dependencyParse_dependencyList = dependencyParse_dependencyList obj} then P.Nothing else P.Just $ default_DependencyParse{dependencyParse_dependencyList = dependencyParse_dependencyList obj}
    , if obj == default_DependencyParse{dependencyParse_structureInformation = dependencyParse_structureInformation obj} then P.Nothing else P.Just $ default_DependencyParse{dependencyParse_structureInformation = dependencyParse_structureInformation obj}
    ]
from_DependencyParse :: DependencyParse -> T.ThriftVal
from_DependencyParse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v82 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v82))) $ dependencyParse_uuid record
  , (\_v82 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v82))) $ dependencyParse_metadata record
  , (\_v82 -> P.Just (3, ("dependencyList",T.TList (T.T_STRUCT typemap_Dependency) $ P.map (\_v84 -> from_Dependency _v84) $ Vector.toList _v82))) $ dependencyParse_dependencyList record
  , (\_v82 -> (4, ("structureInformation",from_DependencyParseStructure _v82))) <$> dependencyParse_structureInformation record
  ]
write_DependencyParse :: (T.Protocol p, T.Transport t) => p t -> DependencyParse -> P.IO ()
write_DependencyParse oprot record = T.writeVal oprot $ from_DependencyParse record
encode_DependencyParse :: (T.Protocol p, T.Transport t) => p t -> DependencyParse -> LBS.ByteString
encode_DependencyParse oprot record = T.serializeVal oprot $ from_DependencyParse record
to_DependencyParse :: T.ThriftVal -> DependencyParse
to_DependencyParse (T.TStruct fields) = DependencyParse{
  dependencyParse_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val86) -> (case _val86 of {T.TStruct _val87 -> (Uuid_Types.to_UUID (T.TStruct _val87)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  dependencyParse_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val86) -> (case _val86 of {T.TStruct _val88 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val88)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  dependencyParse_dependencyList = P.maybe (P.error "Missing required field: dependencyList") (\(_,_val86) -> (case _val86 of {T.TList _ _val89 -> (Vector.fromList $ P.map (\_v90 -> (case _v90 of {T.TStruct _val91 -> (to_Dependency (T.TStruct _val91)); _ -> P.error "wrong type"})) _val89); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  dependencyParse_structureInformation = P.maybe (P.Nothing) (\(_,_val86) -> P.Just (case _val86 of {T.TStruct _val92 -> (to_DependencyParseStructure (T.TStruct _val92)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_DependencyParse _ = P.error "not a struct"
read_DependencyParse :: (T.Transport t, T.Protocol p) => p t -> P.IO DependencyParse
read_DependencyParse iprot = to_DependencyParse <$> T.readVal iprot (T.T_STRUCT typemap_DependencyParse)
decode_DependencyParse :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DependencyParse
decode_DependencyParse iprot bs = to_DependencyParse $ T.deserializeVal iprot (T.T_STRUCT typemap_DependencyParse) bs
typemap_DependencyParse :: T.TypeMap
typemap_DependencyParse = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("dependencyList",(T.T_LIST (T.T_STRUCT typemap_Dependency)))),(4,("structureInformation",(T.T_STRUCT typemap_DependencyParseStructure)))]
default_DependencyParse :: DependencyParse
default_DependencyParse = DependencyParse{
  dependencyParse_uuid = Uuid_Types.default_UUID,
  dependencyParse_metadata = Metadata_Types.default_AnnotationMetadata,
  dependencyParse_dependencyList = Vector.empty,
  dependencyParse_structureInformation = P.Nothing}
data Constituent = Constituent  { constituent_id :: I.Int32
  , constituent_tag :: P.Maybe LT.Text
  , constituent_childList :: (Vector.Vector I.Int32)
  , constituent_headChildIndex :: P.Maybe I.Int32
  , constituent_start :: P.Maybe I.Int32
  , constituent_ending :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Constituent where
  hashWithSalt salt record = salt   `H.hashWithSalt` constituent_id record   `H.hashWithSalt` constituent_tag record   `H.hashWithSalt` constituent_childList record   `H.hashWithSalt` constituent_headChildIndex record   `H.hashWithSalt` constituent_start record   `H.hashWithSalt` constituent_ending record  
instance QC.Arbitrary Constituent where 
  arbitrary = M.liftM Constituent (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Constituent = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Constituent{constituent_id = constituent_id obj} then P.Nothing else P.Just $ default_Constituent{constituent_id = constituent_id obj}
    , if obj == default_Constituent{constituent_tag = constituent_tag obj} then P.Nothing else P.Just $ default_Constituent{constituent_tag = constituent_tag obj}
    , if obj == default_Constituent{constituent_childList = constituent_childList obj} then P.Nothing else P.Just $ default_Constituent{constituent_childList = constituent_childList obj}
    , if obj == default_Constituent{constituent_headChildIndex = constituent_headChildIndex obj} then P.Nothing else P.Just $ default_Constituent{constituent_headChildIndex = constituent_headChildIndex obj}
    , if obj == default_Constituent{constituent_start = constituent_start obj} then P.Nothing else P.Just $ default_Constituent{constituent_start = constituent_start obj}
    , if obj == default_Constituent{constituent_ending = constituent_ending obj} then P.Nothing else P.Just $ default_Constituent{constituent_ending = constituent_ending obj}
    ]
from_Constituent :: Constituent -> T.ThriftVal
from_Constituent record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v95 -> P.Just (1, ("id",T.TI32 _v95))) $ constituent_id record
  , (\_v95 -> (2, ("tag",T.TString $ E.encodeUtf8 _v95))) <$> constituent_tag record
  , (\_v95 -> P.Just (3, ("childList",T.TList T.T_I32 $ P.map (\_v97 -> T.TI32 _v97) $ Vector.toList _v95))) $ constituent_childList record
  , (\_v95 -> (4, ("headChildIndex",T.TI32 _v95))) <$> constituent_headChildIndex record
  , (\_v95 -> (5, ("start",T.TI32 _v95))) <$> constituent_start record
  , (\_v95 -> (6, ("ending",T.TI32 _v95))) <$> constituent_ending record
  ]
write_Constituent :: (T.Protocol p, T.Transport t) => p t -> Constituent -> P.IO ()
write_Constituent oprot record = T.writeVal oprot $ from_Constituent record
encode_Constituent :: (T.Protocol p, T.Transport t) => p t -> Constituent -> LBS.ByteString
encode_Constituent oprot record = T.serializeVal oprot $ from_Constituent record
to_Constituent :: T.ThriftVal -> Constituent
to_Constituent (T.TStruct fields) = Constituent{
  constituent_id = P.maybe (P.error "Missing required field: id") (\(_,_val99) -> (case _val99 of {T.TI32 _val100 -> _val100; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  constituent_tag = P.maybe (P.Nothing) (\(_,_val99) -> P.Just (case _val99 of {T.TString _val101 -> E.decodeUtf8 _val101; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  constituent_childList = P.maybe (P.error "Missing required field: childList") (\(_,_val99) -> (case _val99 of {T.TList _ _val102 -> (Vector.fromList $ P.map (\_v103 -> (case _v103 of {T.TI32 _val104 -> _val104; _ -> P.error "wrong type"})) _val102); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  constituent_headChildIndex = P.maybe (constituent_headChildIndex default_Constituent) (\(_,_val99) -> P.Just (case _val99 of {T.TI32 _val105 -> _val105; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  constituent_start = P.maybe (P.Nothing) (\(_,_val99) -> P.Just (case _val99 of {T.TI32 _val106 -> _val106; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  constituent_ending = P.maybe (P.Nothing) (\(_,_val99) -> P.Just (case _val99 of {T.TI32 _val107 -> _val107; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_Constituent _ = P.error "not a struct"
read_Constituent :: (T.Transport t, T.Protocol p) => p t -> P.IO Constituent
read_Constituent iprot = to_Constituent <$> T.readVal iprot (T.T_STRUCT typemap_Constituent)
decode_Constituent :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Constituent
decode_Constituent iprot bs = to_Constituent $ T.deserializeVal iprot (T.T_STRUCT typemap_Constituent) bs
typemap_Constituent :: T.TypeMap
typemap_Constituent = Map.fromList [(1,("id",T.T_I32)),(2,("tag",T.T_STRING)),(3,("childList",(T.T_LIST T.T_I32))),(4,("headChildIndex",T.T_I32)),(5,("start",T.T_I32)),(6,("ending",T.T_I32))]
default_Constituent :: Constituent
default_Constituent = Constituent{
  constituent_id = 0,
  constituent_tag = P.Nothing,
  constituent_childList = Vector.empty,
  constituent_headChildIndex = P.Just (-1),
  constituent_start = P.Nothing,
  constituent_ending = P.Nothing}
data Parse = Parse  { parse_uuid :: Uuid_Types.UUID
  , parse_metadata :: Metadata_Types.AnnotationMetadata
  , parse_constituentList :: (Vector.Vector Constituent)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Parse where
  hashWithSalt salt record = salt   `H.hashWithSalt` parse_uuid record   `H.hashWithSalt` parse_metadata record   `H.hashWithSalt` parse_constituentList record  
instance QC.Arbitrary Parse where 
  arbitrary = M.liftM Parse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Parse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Parse{parse_uuid = parse_uuid obj} then P.Nothing else P.Just $ default_Parse{parse_uuid = parse_uuid obj}
    , if obj == default_Parse{parse_metadata = parse_metadata obj} then P.Nothing else P.Just $ default_Parse{parse_metadata = parse_metadata obj}
    , if obj == default_Parse{parse_constituentList = parse_constituentList obj} then P.Nothing else P.Just $ default_Parse{parse_constituentList = parse_constituentList obj}
    ]
from_Parse :: Parse -> T.ThriftVal
from_Parse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v110 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v110))) $ parse_uuid record
  , (\_v110 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v110))) $ parse_metadata record
  , (\_v110 -> P.Just (3, ("constituentList",T.TList (T.T_STRUCT typemap_Constituent) $ P.map (\_v112 -> from_Constituent _v112) $ Vector.toList _v110))) $ parse_constituentList record
  ]
write_Parse :: (T.Protocol p, T.Transport t) => p t -> Parse -> P.IO ()
write_Parse oprot record = T.writeVal oprot $ from_Parse record
encode_Parse :: (T.Protocol p, T.Transport t) => p t -> Parse -> LBS.ByteString
encode_Parse oprot record = T.serializeVal oprot $ from_Parse record
to_Parse :: T.ThriftVal -> Parse
to_Parse (T.TStruct fields) = Parse{
  parse_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val114) -> (case _val114 of {T.TStruct _val115 -> (Uuid_Types.to_UUID (T.TStruct _val115)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  parse_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val114) -> (case _val114 of {T.TStruct _val116 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val116)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  parse_constituentList = P.maybe (P.error "Missing required field: constituentList") (\(_,_val114) -> (case _val114 of {T.TList _ _val117 -> (Vector.fromList $ P.map (\_v118 -> (case _v118 of {T.TStruct _val119 -> (to_Constituent (T.TStruct _val119)); _ -> P.error "wrong type"})) _val117); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Parse _ = P.error "not a struct"
read_Parse :: (T.Transport t, T.Protocol p) => p t -> P.IO Parse
read_Parse iprot = to_Parse <$> T.readVal iprot (T.T_STRUCT typemap_Parse)
decode_Parse :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Parse
decode_Parse iprot bs = to_Parse $ T.deserializeVal iprot (T.T_STRUCT typemap_Parse) bs
typemap_Parse :: T.TypeMap
typemap_Parse = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("constituentList",(T.T_LIST (T.T_STRUCT typemap_Constituent))))]
default_Parse :: Parse
default_Parse = Parse{
  parse_uuid = Uuid_Types.default_UUID,
  parse_metadata = Metadata_Types.default_AnnotationMetadata,
  parse_constituentList = Vector.empty}
data LatticePath = LatticePath  { latticePath_weight :: P.Maybe P.Double
  , latticePath_tokenList :: (Vector.Vector Token)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LatticePath where
  hashWithSalt salt record = salt   `H.hashWithSalt` latticePath_weight record   `H.hashWithSalt` latticePath_tokenList record  
instance QC.Arbitrary LatticePath where 
  arbitrary = M.liftM LatticePath (M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LatticePath = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LatticePath{latticePath_weight = latticePath_weight obj} then P.Nothing else P.Just $ default_LatticePath{latticePath_weight = latticePath_weight obj}
    , if obj == default_LatticePath{latticePath_tokenList = latticePath_tokenList obj} then P.Nothing else P.Just $ default_LatticePath{latticePath_tokenList = latticePath_tokenList obj}
    ]
from_LatticePath :: LatticePath -> T.ThriftVal
from_LatticePath record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v122 -> (1, ("weight",T.TDouble _v122))) <$> latticePath_weight record
  , (\_v122 -> P.Just (2, ("tokenList",T.TList (T.T_STRUCT typemap_Token) $ P.map (\_v124 -> from_Token _v124) $ Vector.toList _v122))) $ latticePath_tokenList record
  ]
write_LatticePath :: (T.Protocol p, T.Transport t) => p t -> LatticePath -> P.IO ()
write_LatticePath oprot record = T.writeVal oprot $ from_LatticePath record
encode_LatticePath :: (T.Protocol p, T.Transport t) => p t -> LatticePath -> LBS.ByteString
encode_LatticePath oprot record = T.serializeVal oprot $ from_LatticePath record
to_LatticePath :: T.ThriftVal -> LatticePath
to_LatticePath (T.TStruct fields) = LatticePath{
  latticePath_weight = P.maybe (P.Nothing) (\(_,_val126) -> P.Just (case _val126 of {T.TDouble _val127 -> _val127; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  latticePath_tokenList = P.maybe (P.error "Missing required field: tokenList") (\(_,_val126) -> (case _val126 of {T.TList _ _val128 -> (Vector.fromList $ P.map (\_v129 -> (case _v129 of {T.TStruct _val130 -> (to_Token (T.TStruct _val130)); _ -> P.error "wrong type"})) _val128); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LatticePath _ = P.error "not a struct"
read_LatticePath :: (T.Transport t, T.Protocol p) => p t -> P.IO LatticePath
read_LatticePath iprot = to_LatticePath <$> T.readVal iprot (T.T_STRUCT typemap_LatticePath)
decode_LatticePath :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> LatticePath
decode_LatticePath iprot bs = to_LatticePath $ T.deserializeVal iprot (T.T_STRUCT typemap_LatticePath) bs
typemap_LatticePath :: T.TypeMap
typemap_LatticePath = Map.fromList [(1,("weight",T.T_DOUBLE)),(2,("tokenList",(T.T_LIST (T.T_STRUCT typemap_Token))))]
default_LatticePath :: LatticePath
default_LatticePath = LatticePath{
  latticePath_weight = P.Nothing,
  latticePath_tokenList = Vector.empty}
data Arc = Arc  { arc_src :: P.Maybe I.Int32
  , arc_dst :: P.Maybe I.Int32
  , arc_token :: P.Maybe Token
  , arc_weight :: P.Maybe P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Arc where
  hashWithSalt salt record = salt   `H.hashWithSalt` arc_src record   `H.hashWithSalt` arc_dst record   `H.hashWithSalt` arc_token record   `H.hashWithSalt` arc_weight record  
instance QC.Arbitrary Arc where 
  arbitrary = M.liftM Arc (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Arc = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Arc{arc_src = arc_src obj} then P.Nothing else P.Just $ default_Arc{arc_src = arc_src obj}
    , if obj == default_Arc{arc_dst = arc_dst obj} then P.Nothing else P.Just $ default_Arc{arc_dst = arc_dst obj}
    , if obj == default_Arc{arc_token = arc_token obj} then P.Nothing else P.Just $ default_Arc{arc_token = arc_token obj}
    , if obj == default_Arc{arc_weight = arc_weight obj} then P.Nothing else P.Just $ default_Arc{arc_weight = arc_weight obj}
    ]
from_Arc :: Arc -> T.ThriftVal
from_Arc record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v133 -> (1, ("src",T.TI32 _v133))) <$> arc_src record
  , (\_v133 -> (2, ("dst",T.TI32 _v133))) <$> arc_dst record
  , (\_v133 -> (3, ("token",from_Token _v133))) <$> arc_token record
  , (\_v133 -> (4, ("weight",T.TDouble _v133))) <$> arc_weight record
  ]
write_Arc :: (T.Protocol p, T.Transport t) => p t -> Arc -> P.IO ()
write_Arc oprot record = T.writeVal oprot $ from_Arc record
encode_Arc :: (T.Protocol p, T.Transport t) => p t -> Arc -> LBS.ByteString
encode_Arc oprot record = T.serializeVal oprot $ from_Arc record
to_Arc :: T.ThriftVal -> Arc
to_Arc (T.TStruct fields) = Arc{
  arc_src = P.maybe (P.Nothing) (\(_,_val135) -> P.Just (case _val135 of {T.TI32 _val136 -> _val136; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  arc_dst = P.maybe (P.Nothing) (\(_,_val135) -> P.Just (case _val135 of {T.TI32 _val137 -> _val137; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  arc_token = P.maybe (P.Nothing) (\(_,_val135) -> P.Just (case _val135 of {T.TStruct _val138 -> (to_Token (T.TStruct _val138)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  arc_weight = P.maybe (P.Nothing) (\(_,_val135) -> P.Just (case _val135 of {T.TDouble _val139 -> _val139; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Arc _ = P.error "not a struct"
read_Arc :: (T.Transport t, T.Protocol p) => p t -> P.IO Arc
read_Arc iprot = to_Arc <$> T.readVal iprot (T.T_STRUCT typemap_Arc)
decode_Arc :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Arc
decode_Arc iprot bs = to_Arc $ T.deserializeVal iprot (T.T_STRUCT typemap_Arc) bs
typemap_Arc :: T.TypeMap
typemap_Arc = Map.fromList [(1,("src",T.T_I32)),(2,("dst",T.T_I32)),(3,("token",(T.T_STRUCT typemap_Token))),(4,("weight",T.T_DOUBLE))]
default_Arc :: Arc
default_Arc = Arc{
  arc_src = P.Nothing,
  arc_dst = P.Nothing,
  arc_token = P.Nothing,
  arc_weight = P.Nothing}
data TokenLattice = TokenLattice  { tokenLattice_startState :: P.Maybe I.Int32
  , tokenLattice_endState :: P.Maybe I.Int32
  , tokenLattice_arcList :: (Vector.Vector Arc)
  , tokenLattice_cachedBestPath :: P.Maybe LatticePath
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TokenLattice where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenLattice_startState record   `H.hashWithSalt` tokenLattice_endState record   `H.hashWithSalt` tokenLattice_arcList record   `H.hashWithSalt` tokenLattice_cachedBestPath record  
instance QC.Arbitrary TokenLattice where 
  arbitrary = M.liftM TokenLattice (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TokenLattice = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TokenLattice{tokenLattice_startState = tokenLattice_startState obj} then P.Nothing else P.Just $ default_TokenLattice{tokenLattice_startState = tokenLattice_startState obj}
    , if obj == default_TokenLattice{tokenLattice_endState = tokenLattice_endState obj} then P.Nothing else P.Just $ default_TokenLattice{tokenLattice_endState = tokenLattice_endState obj}
    , if obj == default_TokenLattice{tokenLattice_arcList = tokenLattice_arcList obj} then P.Nothing else P.Just $ default_TokenLattice{tokenLattice_arcList = tokenLattice_arcList obj}
    , if obj == default_TokenLattice{tokenLattice_cachedBestPath = tokenLattice_cachedBestPath obj} then P.Nothing else P.Just $ default_TokenLattice{tokenLattice_cachedBestPath = tokenLattice_cachedBestPath obj}
    ]
from_TokenLattice :: TokenLattice -> T.ThriftVal
from_TokenLattice record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v142 -> (1, ("startState",T.TI32 _v142))) <$> tokenLattice_startState record
  , (\_v142 -> (2, ("endState",T.TI32 _v142))) <$> tokenLattice_endState record
  , (\_v142 -> P.Just (3, ("arcList",T.TList (T.T_STRUCT typemap_Arc) $ P.map (\_v144 -> from_Arc _v144) $ Vector.toList _v142))) $ tokenLattice_arcList record
  , (\_v142 -> (4, ("cachedBestPath",from_LatticePath _v142))) <$> tokenLattice_cachedBestPath record
  ]
write_TokenLattice :: (T.Protocol p, T.Transport t) => p t -> TokenLattice -> P.IO ()
write_TokenLattice oprot record = T.writeVal oprot $ from_TokenLattice record
encode_TokenLattice :: (T.Protocol p, T.Transport t) => p t -> TokenLattice -> LBS.ByteString
encode_TokenLattice oprot record = T.serializeVal oprot $ from_TokenLattice record
to_TokenLattice :: T.ThriftVal -> TokenLattice
to_TokenLattice (T.TStruct fields) = TokenLattice{
  tokenLattice_startState = P.maybe (tokenLattice_startState default_TokenLattice) (\(_,_val146) -> P.Just (case _val146 of {T.TI32 _val147 -> _val147; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tokenLattice_endState = P.maybe (tokenLattice_endState default_TokenLattice) (\(_,_val146) -> P.Just (case _val146 of {T.TI32 _val148 -> _val148; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tokenLattice_arcList = P.maybe (P.error "Missing required field: arcList") (\(_,_val146) -> (case _val146 of {T.TList _ _val149 -> (Vector.fromList $ P.map (\_v150 -> (case _v150 of {T.TStruct _val151 -> (to_Arc (T.TStruct _val151)); _ -> P.error "wrong type"})) _val149); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tokenLattice_cachedBestPath = P.maybe (P.Nothing) (\(_,_val146) -> P.Just (case _val146 of {T.TStruct _val152 -> (to_LatticePath (T.TStruct _val152)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TokenLattice _ = P.error "not a struct"
read_TokenLattice :: (T.Transport t, T.Protocol p) => p t -> P.IO TokenLattice
read_TokenLattice iprot = to_TokenLattice <$> T.readVal iprot (T.T_STRUCT typemap_TokenLattice)
decode_TokenLattice :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TokenLattice
decode_TokenLattice iprot bs = to_TokenLattice $ T.deserializeVal iprot (T.T_STRUCT typemap_TokenLattice) bs
typemap_TokenLattice :: T.TypeMap
typemap_TokenLattice = Map.fromList [(1,("startState",T.T_I32)),(2,("endState",T.T_I32)),(3,("arcList",(T.T_LIST (T.T_STRUCT typemap_Arc)))),(4,("cachedBestPath",(T.T_STRUCT typemap_LatticePath)))]
default_TokenLattice :: TokenLattice
default_TokenLattice = TokenLattice{
  tokenLattice_startState = P.Just (0),
  tokenLattice_endState = P.Just (0),
  tokenLattice_arcList = Vector.empty,
  tokenLattice_cachedBestPath = P.Nothing}
data TokenList = TokenList  { tokenList_tokenList :: (Vector.Vector Token)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TokenList where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenList_tokenList record  
instance QC.Arbitrary TokenList where 
  arbitrary = M.liftM TokenList (QC.arbitrary)
  shrink obj | obj == default_TokenList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TokenList{tokenList_tokenList = tokenList_tokenList obj} then P.Nothing else P.Just $ default_TokenList{tokenList_tokenList = tokenList_tokenList obj}
    ]
from_TokenList :: TokenList -> T.ThriftVal
from_TokenList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v155 -> P.Just (1, ("tokenList",T.TList (T.T_STRUCT typemap_Token) $ P.map (\_v157 -> from_Token _v157) $ Vector.toList _v155))) $ tokenList_tokenList record
  ]
write_TokenList :: (T.Protocol p, T.Transport t) => p t -> TokenList -> P.IO ()
write_TokenList oprot record = T.writeVal oprot $ from_TokenList record
encode_TokenList :: (T.Protocol p, T.Transport t) => p t -> TokenList -> LBS.ByteString
encode_TokenList oprot record = T.serializeVal oprot $ from_TokenList record
to_TokenList :: T.ThriftVal -> TokenList
to_TokenList (T.TStruct fields) = TokenList{
  tokenList_tokenList = P.maybe (P.error "Missing required field: tokenList") (\(_,_val159) -> (case _val159 of {T.TList _ _val160 -> (Vector.fromList $ P.map (\_v161 -> (case _v161 of {T.TStruct _val162 -> (to_Token (T.TStruct _val162)); _ -> P.error "wrong type"})) _val160); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TokenList _ = P.error "not a struct"
read_TokenList :: (T.Transport t, T.Protocol p) => p t -> P.IO TokenList
read_TokenList iprot = to_TokenList <$> T.readVal iprot (T.T_STRUCT typemap_TokenList)
decode_TokenList :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TokenList
decode_TokenList iprot bs = to_TokenList $ T.deserializeVal iprot (T.T_STRUCT typemap_TokenList) bs
typemap_TokenList :: T.TypeMap
typemap_TokenList = Map.fromList [(1,("tokenList",(T.T_LIST (T.T_STRUCT typemap_Token))))]
default_TokenList :: TokenList
default_TokenList = TokenList{
  tokenList_tokenList = Vector.empty}
data SpanLink = SpanLink  { spanLink_tokens :: TokenRefSequence
  , spanLink_concreteTarget :: P.Maybe Uuid_Types.UUID
  , spanLink_externalTarget :: P.Maybe LT.Text
  , spanLink_linkType :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SpanLink where
  hashWithSalt salt record = salt   `H.hashWithSalt` spanLink_tokens record   `H.hashWithSalt` spanLink_concreteTarget record   `H.hashWithSalt` spanLink_externalTarget record   `H.hashWithSalt` spanLink_linkType record  
instance QC.Arbitrary SpanLink where 
  arbitrary = M.liftM SpanLink (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SpanLink = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SpanLink{spanLink_tokens = spanLink_tokens obj} then P.Nothing else P.Just $ default_SpanLink{spanLink_tokens = spanLink_tokens obj}
    , if obj == default_SpanLink{spanLink_concreteTarget = spanLink_concreteTarget obj} then P.Nothing else P.Just $ default_SpanLink{spanLink_concreteTarget = spanLink_concreteTarget obj}
    , if obj == default_SpanLink{spanLink_externalTarget = spanLink_externalTarget obj} then P.Nothing else P.Just $ default_SpanLink{spanLink_externalTarget = spanLink_externalTarget obj}
    , if obj == default_SpanLink{spanLink_linkType = spanLink_linkType obj} then P.Nothing else P.Just $ default_SpanLink{spanLink_linkType = spanLink_linkType obj}
    ]
from_SpanLink :: SpanLink -> T.ThriftVal
from_SpanLink record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v165 -> P.Just (1, ("tokens",from_TokenRefSequence _v165))) $ spanLink_tokens record
  , (\_v165 -> (2, ("concreteTarget",Uuid_Types.from_UUID _v165))) <$> spanLink_concreteTarget record
  , (\_v165 -> (3, ("externalTarget",T.TString $ E.encodeUtf8 _v165))) <$> spanLink_externalTarget record
  , (\_v165 -> P.Just (4, ("linkType",T.TString $ E.encodeUtf8 _v165))) $ spanLink_linkType record
  ]
write_SpanLink :: (T.Protocol p, T.Transport t) => p t -> SpanLink -> P.IO ()
write_SpanLink oprot record = T.writeVal oprot $ from_SpanLink record
encode_SpanLink :: (T.Protocol p, T.Transport t) => p t -> SpanLink -> LBS.ByteString
encode_SpanLink oprot record = T.serializeVal oprot $ from_SpanLink record
to_SpanLink :: T.ThriftVal -> SpanLink
to_SpanLink (T.TStruct fields) = SpanLink{
  spanLink_tokens = P.maybe (P.error "Missing required field: tokens") (\(_,_val167) -> (case _val167 of {T.TStruct _val168 -> (to_TokenRefSequence (T.TStruct _val168)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  spanLink_concreteTarget = P.maybe (P.Nothing) (\(_,_val167) -> P.Just (case _val167 of {T.TStruct _val169 -> (Uuid_Types.to_UUID (T.TStruct _val169)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  spanLink_externalTarget = P.maybe (P.Nothing) (\(_,_val167) -> P.Just (case _val167 of {T.TString _val170 -> E.decodeUtf8 _val170; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  spanLink_linkType = P.maybe (P.error "Missing required field: linkType") (\(_,_val167) -> (case _val167 of {T.TString _val171 -> E.decodeUtf8 _val171; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SpanLink _ = P.error "not a struct"
read_SpanLink :: (T.Transport t, T.Protocol p) => p t -> P.IO SpanLink
read_SpanLink iprot = to_SpanLink <$> T.readVal iprot (T.T_STRUCT typemap_SpanLink)
decode_SpanLink :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SpanLink
decode_SpanLink iprot bs = to_SpanLink $ T.deserializeVal iprot (T.T_STRUCT typemap_SpanLink) bs
typemap_SpanLink :: T.TypeMap
typemap_SpanLink = Map.fromList [(1,("tokens",(T.T_STRUCT typemap_TokenRefSequence))),(2,("concreteTarget",(T.T_STRUCT Uuid_Types.typemap_UUID))),(3,("externalTarget",T.T_STRING)),(4,("linkType",T.T_STRING))]
default_SpanLink :: SpanLink
default_SpanLink = SpanLink{
  spanLink_tokens = default_TokenRefSequence,
  spanLink_concreteTarget = P.Nothing,
  spanLink_externalTarget = P.Nothing,
  spanLink_linkType = ""}
data Tokenization = Tokenization  { tokenization_uuid :: Uuid_Types.UUID
  , tokenization_metadata :: Metadata_Types.AnnotationMetadata
  , tokenization_tokenList :: P.Maybe TokenList
  , tokenization_lattice :: P.Maybe TokenLattice
  , tokenization_kind :: TokenizationKind
  , tokenization_tokenTaggingList :: P.Maybe (Vector.Vector TokenTagging)
  , tokenization_parseList :: P.Maybe (Vector.Vector Parse)
  , tokenization_dependencyParseList :: P.Maybe (Vector.Vector DependencyParse)
  , tokenization_spanLinkList :: P.Maybe (Vector.Vector SpanLink)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Tokenization where
  hashWithSalt salt record = salt   `H.hashWithSalt` tokenization_uuid record   `H.hashWithSalt` tokenization_metadata record   `H.hashWithSalt` tokenization_tokenList record   `H.hashWithSalt` tokenization_lattice record   `H.hashWithSalt` tokenization_kind record   `H.hashWithSalt` tokenization_tokenTaggingList record   `H.hashWithSalt` tokenization_parseList record   `H.hashWithSalt` tokenization_dependencyParseList record   `H.hashWithSalt` tokenization_spanLinkList record  
instance QC.Arbitrary Tokenization where 
  arbitrary = M.liftM Tokenization (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Tokenization = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Tokenization{tokenization_uuid = tokenization_uuid obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_uuid = tokenization_uuid obj}
    , if obj == default_Tokenization{tokenization_metadata = tokenization_metadata obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_metadata = tokenization_metadata obj}
    , if obj == default_Tokenization{tokenization_tokenList = tokenization_tokenList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_tokenList = tokenization_tokenList obj}
    , if obj == default_Tokenization{tokenization_lattice = tokenization_lattice obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_lattice = tokenization_lattice obj}
    , if obj == default_Tokenization{tokenization_kind = tokenization_kind obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_kind = tokenization_kind obj}
    , if obj == default_Tokenization{tokenization_tokenTaggingList = tokenization_tokenTaggingList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_tokenTaggingList = tokenization_tokenTaggingList obj}
    , if obj == default_Tokenization{tokenization_parseList = tokenization_parseList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_parseList = tokenization_parseList obj}
    , if obj == default_Tokenization{tokenization_dependencyParseList = tokenization_dependencyParseList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_dependencyParseList = tokenization_dependencyParseList obj}
    , if obj == default_Tokenization{tokenization_spanLinkList = tokenization_spanLinkList obj} then P.Nothing else P.Just $ default_Tokenization{tokenization_spanLinkList = tokenization_spanLinkList obj}
    ]
from_Tokenization :: Tokenization -> T.ThriftVal
from_Tokenization record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v174 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v174))) $ tokenization_uuid record
  , (\_v174 -> P.Just (2, ("metadata",Metadata_Types.from_AnnotationMetadata _v174))) $ tokenization_metadata record
  , (\_v174 -> (3, ("tokenList",from_TokenList _v174))) <$> tokenization_tokenList record
  , (\_v174 -> (4, ("lattice",from_TokenLattice _v174))) <$> tokenization_lattice record
  , (\_v174 -> P.Just (5, ("kind",T.TI32 $ P.fromIntegral $ P.fromEnum _v174))) $ tokenization_kind record
  , (\_v174 -> (6, ("tokenTaggingList",T.TList (T.T_STRUCT typemap_TokenTagging) $ P.map (\_v176 -> from_TokenTagging _v176) $ Vector.toList _v174))) <$> tokenization_tokenTaggingList record
  , (\_v174 -> (7, ("parseList",T.TList (T.T_STRUCT typemap_Parse) $ P.map (\_v178 -> from_Parse _v178) $ Vector.toList _v174))) <$> tokenization_parseList record
  , (\_v174 -> (8, ("dependencyParseList",T.TList (T.T_STRUCT typemap_DependencyParse) $ P.map (\_v180 -> from_DependencyParse _v180) $ Vector.toList _v174))) <$> tokenization_dependencyParseList record
  , (\_v174 -> (9, ("spanLinkList",T.TList (T.T_STRUCT typemap_SpanLink) $ P.map (\_v182 -> from_SpanLink _v182) $ Vector.toList _v174))) <$> tokenization_spanLinkList record
  ]
write_Tokenization :: (T.Protocol p, T.Transport t) => p t -> Tokenization -> P.IO ()
write_Tokenization oprot record = T.writeVal oprot $ from_Tokenization record
encode_Tokenization :: (T.Protocol p, T.Transport t) => p t -> Tokenization -> LBS.ByteString
encode_Tokenization oprot record = T.serializeVal oprot $ from_Tokenization record
to_Tokenization :: T.ThriftVal -> Tokenization
to_Tokenization (T.TStruct fields) = Tokenization{
  tokenization_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val184) -> (case _val184 of {T.TStruct _val185 -> (Uuid_Types.to_UUID (T.TStruct _val185)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tokenization_metadata = P.maybe (P.error "Missing required field: metadata") (\(_,_val184) -> (case _val184 of {T.TStruct _val186 -> (Metadata_Types.to_AnnotationMetadata (T.TStruct _val186)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tokenization_tokenList = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TStruct _val187 -> (to_TokenList (T.TStruct _val187)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tokenization_lattice = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TStruct _val188 -> (to_TokenLattice (T.TStruct _val188)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  tokenization_kind = P.maybe (P.error "Missing required field: kind") (\(_,_val184) -> (case _val184 of {T.TI32 _val189 -> P.toEnum $ P.fromIntegral _val189; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  tokenization_tokenTaggingList = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TList _ _val190 -> (Vector.fromList $ P.map (\_v191 -> (case _v191 of {T.TStruct _val192 -> (to_TokenTagging (T.TStruct _val192)); _ -> P.error "wrong type"})) _val190); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  tokenization_parseList = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TList _ _val193 -> (Vector.fromList $ P.map (\_v194 -> (case _v194 of {T.TStruct _val195 -> (to_Parse (T.TStruct _val195)); _ -> P.error "wrong type"})) _val193); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  tokenization_dependencyParseList = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TList _ _val196 -> (Vector.fromList $ P.map (\_v197 -> (case _v197 of {T.TStruct _val198 -> (to_DependencyParse (T.TStruct _val198)); _ -> P.error "wrong type"})) _val196); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  tokenization_spanLinkList = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TList _ _val199 -> (Vector.fromList $ P.map (\_v200 -> (case _v200 of {T.TStruct _val201 -> (to_SpanLink (T.TStruct _val201)); _ -> P.error "wrong type"})) _val199); _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_Tokenization _ = P.error "not a struct"
read_Tokenization :: (T.Transport t, T.Protocol p) => p t -> P.IO Tokenization
read_Tokenization iprot = to_Tokenization <$> T.readVal iprot (T.T_STRUCT typemap_Tokenization)
decode_Tokenization :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Tokenization
decode_Tokenization iprot bs = to_Tokenization $ T.deserializeVal iprot (T.T_STRUCT typemap_Tokenization) bs
typemap_Tokenization :: T.TypeMap
typemap_Tokenization = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("metadata",(T.T_STRUCT Metadata_Types.typemap_AnnotationMetadata))),(3,("tokenList",(T.T_STRUCT typemap_TokenList))),(4,("lattice",(T.T_STRUCT typemap_TokenLattice))),(5,("kind",T.T_I32)),(6,("tokenTaggingList",(T.T_LIST (T.T_STRUCT typemap_TokenTagging)))),(7,("parseList",(T.T_LIST (T.T_STRUCT typemap_Parse)))),(8,("dependencyParseList",(T.T_LIST (T.T_STRUCT typemap_DependencyParse)))),(9,("spanLinkList",(T.T_LIST (T.T_STRUCT typemap_SpanLink))))]
default_Tokenization :: Tokenization
default_Tokenization = Tokenization{
  tokenization_uuid = Uuid_Types.default_UUID,
  tokenization_metadata = Metadata_Types.default_AnnotationMetadata,
  tokenization_tokenList = P.Nothing,
  tokenization_lattice = P.Nothing,
  tokenization_kind = (P.toEnum 0),
  tokenization_tokenTaggingList = P.Nothing,
  tokenization_parseList = P.Nothing,
  tokenization_dependencyParseList = P.Nothing,
  tokenization_spanLinkList = P.Nothing}
data Sentence = Sentence  { sentence_uuid :: Uuid_Types.UUID
  , sentence_tokenization :: P.Maybe Tokenization
  , sentence_textSpan :: P.Maybe Spans_Types.TextSpan
  , sentence_rawTextSpan :: P.Maybe Spans_Types.TextSpan
  , sentence_audioSpan :: P.Maybe Spans_Types.AudioSpan
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Sentence where
  hashWithSalt salt record = salt   `H.hashWithSalt` sentence_uuid record   `H.hashWithSalt` sentence_tokenization record   `H.hashWithSalt` sentence_textSpan record   `H.hashWithSalt` sentence_rawTextSpan record   `H.hashWithSalt` sentence_audioSpan record  
instance QC.Arbitrary Sentence where 
  arbitrary = M.liftM Sentence (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Sentence = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Sentence{sentence_uuid = sentence_uuid obj} then P.Nothing else P.Just $ default_Sentence{sentence_uuid = sentence_uuid obj}
    , if obj == default_Sentence{sentence_tokenization = sentence_tokenization obj} then P.Nothing else P.Just $ default_Sentence{sentence_tokenization = sentence_tokenization obj}
    , if obj == default_Sentence{sentence_textSpan = sentence_textSpan obj} then P.Nothing else P.Just $ default_Sentence{sentence_textSpan = sentence_textSpan obj}
    , if obj == default_Sentence{sentence_rawTextSpan = sentence_rawTextSpan obj} then P.Nothing else P.Just $ default_Sentence{sentence_rawTextSpan = sentence_rawTextSpan obj}
    , if obj == default_Sentence{sentence_audioSpan = sentence_audioSpan obj} then P.Nothing else P.Just $ default_Sentence{sentence_audioSpan = sentence_audioSpan obj}
    ]
from_Sentence :: Sentence -> T.ThriftVal
from_Sentence record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v204 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v204))) $ sentence_uuid record
  , (\_v204 -> (2, ("tokenization",from_Tokenization _v204))) <$> sentence_tokenization record
  , (\_v204 -> (3, ("textSpan",Spans_Types.from_TextSpan _v204))) <$> sentence_textSpan record
  , (\_v204 -> (4, ("rawTextSpan",Spans_Types.from_TextSpan _v204))) <$> sentence_rawTextSpan record
  , (\_v204 -> (5, ("audioSpan",Spans_Types.from_AudioSpan _v204))) <$> sentence_audioSpan record
  ]
write_Sentence :: (T.Protocol p, T.Transport t) => p t -> Sentence -> P.IO ()
write_Sentence oprot record = T.writeVal oprot $ from_Sentence record
encode_Sentence :: (T.Protocol p, T.Transport t) => p t -> Sentence -> LBS.ByteString
encode_Sentence oprot record = T.serializeVal oprot $ from_Sentence record
to_Sentence :: T.ThriftVal -> Sentence
to_Sentence (T.TStruct fields) = Sentence{
  sentence_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val206) -> (case _val206 of {T.TStruct _val207 -> (Uuid_Types.to_UUID (T.TStruct _val207)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sentence_tokenization = P.maybe (P.Nothing) (\(_,_val206) -> P.Just (case _val206 of {T.TStruct _val208 -> (to_Tokenization (T.TStruct _val208)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sentence_textSpan = P.maybe (P.Nothing) (\(_,_val206) -> P.Just (case _val206 of {T.TStruct _val209 -> (Spans_Types.to_TextSpan (T.TStruct _val209)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  sentence_rawTextSpan = P.maybe (P.Nothing) (\(_,_val206) -> P.Just (case _val206 of {T.TStruct _val210 -> (Spans_Types.to_TextSpan (T.TStruct _val210)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  sentence_audioSpan = P.maybe (P.Nothing) (\(_,_val206) -> P.Just (case _val206 of {T.TStruct _val211 -> (Spans_Types.to_AudioSpan (T.TStruct _val211)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Sentence _ = P.error "not a struct"
read_Sentence :: (T.Transport t, T.Protocol p) => p t -> P.IO Sentence
read_Sentence iprot = to_Sentence <$> T.readVal iprot (T.T_STRUCT typemap_Sentence)
decode_Sentence :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Sentence
decode_Sentence iprot bs = to_Sentence $ T.deserializeVal iprot (T.T_STRUCT typemap_Sentence) bs
typemap_Sentence :: T.TypeMap
typemap_Sentence = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("tokenization",(T.T_STRUCT typemap_Tokenization))),(3,("textSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(4,("rawTextSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(5,("audioSpan",(T.T_STRUCT Spans_Types.typemap_AudioSpan)))]
default_Sentence :: Sentence
default_Sentence = Sentence{
  sentence_uuid = Uuid_Types.default_UUID,
  sentence_tokenization = P.Nothing,
  sentence_textSpan = P.Nothing,
  sentence_rawTextSpan = P.Nothing,
  sentence_audioSpan = P.Nothing}
data Section = Section  { section_uuid :: Uuid_Types.UUID
  , section_sentenceList :: P.Maybe (Vector.Vector Sentence)
  , section_textSpan :: P.Maybe Spans_Types.TextSpan
  , section_rawTextSpan :: P.Maybe Spans_Types.TextSpan
  , section_audioSpan :: P.Maybe Spans_Types.AudioSpan
  , section_kind :: LT.Text
  , section_label :: P.Maybe LT.Text
  , section_numberList :: P.Maybe (Vector.Vector I.Int32)
  , section_lidList :: P.Maybe (Vector.Vector Language_Types.LanguageIdentification)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Section where
  hashWithSalt salt record = salt   `H.hashWithSalt` section_uuid record   `H.hashWithSalt` section_sentenceList record   `H.hashWithSalt` section_textSpan record   `H.hashWithSalt` section_rawTextSpan record   `H.hashWithSalt` section_audioSpan record   `H.hashWithSalt` section_kind record   `H.hashWithSalt` section_label record   `H.hashWithSalt` section_numberList record   `H.hashWithSalt` section_lidList record  
instance QC.Arbitrary Section where 
  arbitrary = M.liftM Section (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Section = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Section{section_uuid = section_uuid obj} then P.Nothing else P.Just $ default_Section{section_uuid = section_uuid obj}
    , if obj == default_Section{section_sentenceList = section_sentenceList obj} then P.Nothing else P.Just $ default_Section{section_sentenceList = section_sentenceList obj}
    , if obj == default_Section{section_textSpan = section_textSpan obj} then P.Nothing else P.Just $ default_Section{section_textSpan = section_textSpan obj}
    , if obj == default_Section{section_rawTextSpan = section_rawTextSpan obj} then P.Nothing else P.Just $ default_Section{section_rawTextSpan = section_rawTextSpan obj}
    , if obj == default_Section{section_audioSpan = section_audioSpan obj} then P.Nothing else P.Just $ default_Section{section_audioSpan = section_audioSpan obj}
    , if obj == default_Section{section_kind = section_kind obj} then P.Nothing else P.Just $ default_Section{section_kind = section_kind obj}
    , if obj == default_Section{section_label = section_label obj} then P.Nothing else P.Just $ default_Section{section_label = section_label obj}
    , if obj == default_Section{section_numberList = section_numberList obj} then P.Nothing else P.Just $ default_Section{section_numberList = section_numberList obj}
    , if obj == default_Section{section_lidList = section_lidList obj} then P.Nothing else P.Just $ default_Section{section_lidList = section_lidList obj}
    ]
from_Section :: Section -> T.ThriftVal
from_Section record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v214 -> P.Just (1, ("uuid",Uuid_Types.from_UUID _v214))) $ section_uuid record
  , (\_v214 -> (2, ("sentenceList",T.TList (T.T_STRUCT typemap_Sentence) $ P.map (\_v216 -> from_Sentence _v216) $ Vector.toList _v214))) <$> section_sentenceList record
  , (\_v214 -> (3, ("textSpan",Spans_Types.from_TextSpan _v214))) <$> section_textSpan record
  , (\_v214 -> (4, ("rawTextSpan",Spans_Types.from_TextSpan _v214))) <$> section_rawTextSpan record
  , (\_v214 -> P.Just (5, ("kind",T.TString $ E.encodeUtf8 _v214))) $ section_kind record
  , (\_v214 -> (6, ("label",T.TString $ E.encodeUtf8 _v214))) <$> section_label record
  , (\_v214 -> (7, ("numberList",T.TList T.T_I32 $ P.map (\_v218 -> T.TI32 _v218) $ Vector.toList _v214))) <$> section_numberList record
  , (\_v214 -> (8, ("lidList",T.TList (T.T_STRUCT Language_Types.typemap_LanguageIdentification) $ P.map (\_v220 -> Language_Types.from_LanguageIdentification _v220) $ Vector.toList _v214))) <$> section_lidList record
  , (\_v214 -> (9, ("audioSpan",Spans_Types.from_AudioSpan _v214))) <$> section_audioSpan record
  ]
write_Section :: (T.Protocol p, T.Transport t) => p t -> Section -> P.IO ()
write_Section oprot record = T.writeVal oprot $ from_Section record
encode_Section :: (T.Protocol p, T.Transport t) => p t -> Section -> LBS.ByteString
encode_Section oprot record = T.serializeVal oprot $ from_Section record
to_Section :: T.ThriftVal -> Section
to_Section (T.TStruct fields) = Section{
  section_uuid = P.maybe (P.error "Missing required field: uuid") (\(_,_val222) -> (case _val222 of {T.TStruct _val223 -> (Uuid_Types.to_UUID (T.TStruct _val223)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  section_sentenceList = P.maybe (P.Nothing) (\(_,_val222) -> P.Just (case _val222 of {T.TList _ _val224 -> (Vector.fromList $ P.map (\_v225 -> (case _v225 of {T.TStruct _val226 -> (to_Sentence (T.TStruct _val226)); _ -> P.error "wrong type"})) _val224); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  section_textSpan = P.maybe (P.Nothing) (\(_,_val222) -> P.Just (case _val222 of {T.TStruct _val227 -> (Spans_Types.to_TextSpan (T.TStruct _val227)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  section_rawTextSpan = P.maybe (P.Nothing) (\(_,_val222) -> P.Just (case _val222 of {T.TStruct _val228 -> (Spans_Types.to_TextSpan (T.TStruct _val228)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  section_audioSpan = P.maybe (P.Nothing) (\(_,_val222) -> P.Just (case _val222 of {T.TStruct _val229 -> (Spans_Types.to_AudioSpan (T.TStruct _val229)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  section_kind = P.maybe (P.error "Missing required field: kind") (\(_,_val222) -> (case _val222 of {T.TString _val230 -> E.decodeUtf8 _val230; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  section_label = P.maybe (P.Nothing) (\(_,_val222) -> P.Just (case _val222 of {T.TString _val231 -> E.decodeUtf8 _val231; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  section_numberList = P.maybe (P.Nothing) (\(_,_val222) -> P.Just (case _val222 of {T.TList _ _val232 -> (Vector.fromList $ P.map (\_v233 -> (case _v233 of {T.TI32 _val234 -> _val234; _ -> P.error "wrong type"})) _val232); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  section_lidList = P.maybe (P.Nothing) (\(_,_val222) -> P.Just (case _val222 of {T.TList _ _val235 -> (Vector.fromList $ P.map (\_v236 -> (case _v236 of {T.TStruct _val237 -> (Language_Types.to_LanguageIdentification (T.TStruct _val237)); _ -> P.error "wrong type"})) _val235); _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_Section _ = P.error "not a struct"
read_Section :: (T.Transport t, T.Protocol p) => p t -> P.IO Section
read_Section iprot = to_Section <$> T.readVal iprot (T.T_STRUCT typemap_Section)
decode_Section :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Section
decode_Section iprot bs = to_Section $ T.deserializeVal iprot (T.T_STRUCT typemap_Section) bs
typemap_Section :: T.TypeMap
typemap_Section = Map.fromList [(1,("uuid",(T.T_STRUCT Uuid_Types.typemap_UUID))),(2,("sentenceList",(T.T_LIST (T.T_STRUCT typemap_Sentence)))),(3,("textSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(4,("rawTextSpan",(T.T_STRUCT Spans_Types.typemap_TextSpan))),(5,("kind",T.T_STRING)),(6,("label",T.T_STRING)),(7,("numberList",(T.T_LIST T.T_I32))),(8,("lidList",(T.T_LIST (T.T_STRUCT Language_Types.typemap_LanguageIdentification)))),(9,("audioSpan",(T.T_STRUCT Spans_Types.typemap_AudioSpan)))]
default_Section :: Section
default_Section = Section{
  section_uuid = Uuid_Types.default_UUID,
  section_sentenceList = P.Nothing,
  section_textSpan = P.Nothing,
  section_rawTextSpan = P.Nothing,
  section_kind = "",
  section_label = P.Nothing,
  section_numberList = P.Nothing,
  section_lidList = P.Nothing,
  section_audioSpan = P.Nothing}
